/**************************source file list*******************************/
gMystar.h:
/*************************************************
 *  gMystar.h
 *
 *  Copyright (C) 2009  csip(amoblin@gmail.com)
 *
 *  ChangeLog:
 *
 *  Description:
 *	Warning: this file should be in UTF-8.
 *  
 **************************************************/

#include "Mystar.h"
#include <gtkmm.h>
#include <libglademm.h>
#include <libnotifymm.h>
#include <boost/lexical_cast.hpp>
using namespace Gtk;

class gMystar:public Window
{
    public:
        //gMystar(int argc, char* argv[]);
        gMystar();
        ~gMystar();
        static void help();
        static Mystar *mystar;
    protected:
        bool on_key_press_event(GdkEventKey *);
        void on_quit_button_clicked();
        void on_connect_button_clicked();
        void on_disconnect_button_clicked();
        void on_tray_clicked();
        static void show_message(const char *message);
        void show_window();
        static void hide_window();
        //static void *authen(void *);
        static void *test(void *);
        static void *change_ui(void *);

        Glib::RefPtr<Gnome::Glade::Xml> refXml;
        static Window *MainWindow;
        Entry *username_entry;
        Entry *password_entry;
        Entry *fakeAddress_entry;
        Entry *nickname_entry;
        static CheckButton *autologin_checkbutton;
        static Button *connect_button;
        Button *disconnect_button;
        Button *quit_button;
        static Label *status_label;
        static Glib::RefPtr<Gtk::StatusIcon> status_icon;

        pthread_t authen_thread;
        pthread_t change_ui_thread;

        static bool flag;

        static int window_x;
        static int window_y;
        static sigc::connection c;
        static Notify::Notification *n;
};
gMystar.cc:
/**************************************************
 *  gMystar.cc
 *
 *  Copyright (C) 2009  csip(amoblin@gmail.com)
 *
 *  ChangeLog:
 *
 *  Description:
 *	Warning: this file should be in UTF-8.
 *  
 *************************************************/
#include "gMystar.h"
#include <pthread.h>
/* static member */
Mystar *gMystar::mystar;
bool gMystar::flag;
Glib::RefPtr<Gtk::StatusIcon> gMystar::status_icon;
Window *gMystar::MainWindow;
CheckButton *gMystar::autologin_checkbutton;
Button *gMystar::connect_button;
Label *gMystar::status_label;
int gMystar::window_x;
int gMystar::window_y;
sigc::connection gMystar::c;
Notify::Notification *gMystar::n;
/*
gMystar::gMystar(int argc, char *argv[])
{
    Main kit(argc, argv);
    mystar = new Mystar();
    flag = true;

    //tray
    status_icon = StatusIcon::create_from_file("/usr/gMystar/disconnect.png");
    if(status_icon)
    {
        status_icon->set_tooltip("用gtkmm和glade做的锐捷客户端.");
        status_icon->signal_activate().connect(sigc::mem_fun(*this, &gMystar::on_tray_clicked));
    }
    else
    {
        cout<<"create tray icon error!\n";
    }

    refXml = Gnome::Glade::Xml::create("/etc/gMystar/ui.glade");
    //refXml = Gnome::Glade::Xml::create("./gMystar.glade");
    MainWindow= NULL;
    MainWindow= refXml->get_widget("gMystar", MainWindow);

    nickname_entry= NULL;
    nickname_entry = refXml->get_widget("nickname", nickname_entry);
    nickname_entry->set_text(mystar->user.get_nickname());

    username_entry= NULL;
    username_entry= refXml->get_widget("username", username_entry);
    username_entry->set_text(mystar->user.get_username());

    password_entry= NULL;
    password_entry= refXml->get_widget("password", password_entry);
    password_entry->set_text(mystar->user.get_password());

    fakeAddress_entry = NULL;
    fakeAddress_entry = refXml->get_widget("fakeAddress", fakeAddress_entry);
    fakeAddress_entry->set_text(mystar->user.get_fakeAddress());

    autologin_checkbutton = NULL;
    autologin_checkbutton = refXml->get_widget("autologin_checkbutton",autologin_checkbutton);

    connect_button = NULL;
    connect_button = refXml->get_widget("connect_button", connect_button);
    if(connect_button)
    {
        gMystar::c = connect_button->signal_clicked().connect(sigc::mem_fun(*this, &gMystar::on_connect_button_clicked));
    }


    disconnect_button = NULL;
    disconnect_button = refXml->get_widget("disconnect_button", disconnect_button);
    if(disconnect_button)
    {
        gMystar::c = disconnect_button->signal_clicked().connect(sigc::mem_fun(*this, &gMystar::on_disconnect_button_clicked));
    }

    quit_button = NULL;
    quit_button = refXml->get_widget("quit_button", quit_button);
    if(quit_button)
    {
        quit_button->signal_clicked().connect(sigc::mem_fun(*this, &gMystar::on_quit_button_clicked));
    }

    status_label = NULL;
    status_label = refXml->get_widget("status",status_label);

    MainWindow->set_focus(*connect_button);
    MainWindow->show();

    if(mystar->autologin)
        on_connect_button_clicked();

    kit.run();          //这样的话在hide时不退出程序
}
*/
gMystar::gMystar()
{
    mystar = new Mystar();
    flag = true;

    //tray
    status_icon = StatusIcon::create_from_file("/usr/share/gMystar/data/disconnect.png");
    if(status_icon)
    {
        status_icon->set_tooltip("用gtkmm和glade做的锐捷客户端.");
        status_icon->signal_activate().connect(sigc::mem_fun(*this, &gMystar::on_tray_clicked));
    }
    else
    {
        cout<<"create tray icon error!\n";
    }

    refXml = Gnome::Glade::Xml::create("/usr/share/gMystar/data/gMystar.glade","main_window");
	if(!refXml)
		exit(271);

	VBox* main_window = NULL;
    main_window = refXml->get_widget("main_window", main_window);

    nickname_entry= NULL;
    nickname_entry = refXml->get_widget("nickname", nickname_entry);
    nickname_entry->set_text(mystar->user.get_nickname());

    username_entry= NULL;
    username_entry= refXml->get_widget("username", username_entry);
    username_entry->set_text(mystar->user.get_username());

    password_entry= NULL;
    password_entry= refXml->get_widget("password", password_entry);
    password_entry->set_text(mystar->user.get_password());

    fakeAddress_entry = NULL;
    fakeAddress_entry = refXml->get_widget("fakeAddress", fakeAddress_entry);
    fakeAddress_entry->set_text(mystar->user.get_fakeAddress());

    autologin_checkbutton = NULL;
    autologin_checkbutton = refXml->get_widget("autologin_checkbutton",autologin_checkbutton);

    connect_button = NULL;
    connect_button = refXml->get_widget("connect_button", connect_button);
    if(connect_button)
    {
        gMystar::c = connect_button->signal_clicked().connect(sigc::mem_fun(*this, &gMystar::on_connect_button_clicked));
    }


    disconnect_button = NULL;
    disconnect_button = refXml->get_widget("disconnect_button", disconnect_button);
    if(disconnect_button)
    {
        gMystar::c = disconnect_button->signal_clicked().connect(sigc::mem_fun(*this, &gMystar::on_disconnect_button_clicked));
    }

    quit_button = NULL;
    quit_button = refXml->get_widget("quit_button", quit_button);
    if(quit_button)
    {
        quit_button->signal_clicked().connect(sigc::mem_fun(*this, &gMystar::on_quit_button_clicked));
    }

    status_label = NULL;
    status_label = refXml->get_widget("status",status_label);

    /*
	VBox* main_window = dynamic_cast<VBox*>(refXml->get_widget("main_window"));

	nickname_entry = dynamic_cast<Entry*>(refXml->get_widget("nickname"));
    nickname_entry->set_text(mystar->user.get_nickname());

	username_entry = dynamic_cast<Entry*>(refXml->get_widget("name"));
    username_entry->set_text(mystar->user.get_username());

	password_entry = dynamic_cast<Entry*>(refXml->get_widget("password"));
    password_entry->set_text(mystar->user.get_password());

	fakeAddress_entry = dynamic_cast<Entry*>(refXml->get_widget("fakeAddress"));
    fakeAddress_entry->set_text(mystar->user.get_fakeAddress());

    autologin_checkbutton = dynamic_cast<CheckButton*>(refXml->get_widget("autologin_checkbutton"));

    connect_button = dynamic_cast<Button*>(refXml->get_widget("connect_button"));
    if(connect_button)
    {
        gMystar::c = connect_button->signal_clicked().connect(sigc::mem_fun(*this, &gMystar::on_connect_button_clicked));
    }


    disconnect_button = dynamic_cast<Button*>(refXml->get_widget("disconnect_button"));
    if(disconnect_button)
    {
        gMystar::c = disconnect_button->signal_clicked().connect(sigc::mem_fun(*this, &gMystar::on_disconnect_button_clicked));
    }

    quit_button = dynamic_cast<Button*>(refXml->get_widget("quit_button"));
    if(quit_button)
    {
        quit_button->signal_clicked().connect(sigc::mem_fun(*this, &gMystar::on_quit_button_clicked));
    }

    //status_label = dynamic_cast<Label*>(refXml->get_widget("status"));
    */

    add(*main_window);
	show_all();

    if(mystar->autologin)
        on_connect_button_clicked();
}
gMystar::~gMystar()
{
}
void gMystar::on_quit_button_clicked()
{
    //MainWindow->hide();//这样只是隐藏了，如何结束呢？
    hide();//这样只是隐藏了，如何结束呢？
}
void gMystar::on_disconnect_button_clicked()
{
    mystar->logout(SIGINT);
    status_label->set_label("logout...");
    if(!pthread_cancel(authen_thread))
        cout<<"取消认证。。。\n";
}
void gMystar::on_connect_button_clicked()
{
    cout<<"用于连接的账号信息是:"<<endl;
    char str[20];
    strcpy(str,nickname_entry->get_text().c_str());
    mystar->user.set_nickname(str);

    strcpy(str,username_entry->get_text().c_str());
    mystar->user.set_username(str);

    strcpy(str,password_entry->get_text().c_str());
    mystar->user.set_password(str);

    strcpy(str,fakeAddress_entry->get_text().c_str());
    mystar->user.set_fakeAddress(str);

    int res = pthread_create(&authen_thread, NULL,gMystar::test, NULL);
    if(res!=0)
    {
        perror("Thread creation failed");
        exit(EXIT_FAILURE);
    }

    int res2 = pthread_create(&change_ui_thread, NULL,gMystar::change_ui, NULL);
    if(res2!=0)
    {
        perror("Thread creation failed");
        exit(EXIT_FAILURE);
    }
}
void gMystar::help()
{
    printf("to use no gui mode, please type --nogui\n");
}
void gMystar::show_message(const char *message)
{
    cout<<message;
    status_label->set_text(message);
}
void gMystar::on_tray_clicked()
{
    if(MainWindow->is_visible())
        hide_window();
    else
        show_window();
}
void gMystar::show_window()
{
    MainWindow->move(window_x, window_y);
    cout<<"resume the position("<<window_x<<","<<window_y<<")"<<endl;
    MainWindow->show();
}
void gMystar::hide_window()
{
    //MainWindow->get_position(window_x, window_y);
    //cout<<"save the current position ("<<window_x<<","<<window_y<<")"<<endl;
    //hide();
}
void *gMystar::test(void *a)
{
    mystar->authen();
}
void *gMystar::change_ui(void *a)
{
    while(flag)
    {
        int status = mystar->get_status();
        switch(status)
        {
            case 0:
                status_label->set_label(">> Searching for server...\n");
                break;
            case 1:
                status_label->set_label(" Sending user name...");
                break;
            case 2:
                status_label->set_label(" Sending password...");
                break;
            case 3:
                status_icon->set_from_file("/usr/share/gMystar/data/connect.png");
                status_label->set_label("keep sending echo...");

                Notify::init("Icon test");
                n = new Notify::Notification("gMystar", "连接成功", "appointment-new");
                n->set_timeout(1000); //1 seconds
                n->show();
                
                hide_window();
                if(autologin_checkbutton->get_active())
                    mystar->autologin=true;
                else
                    mystar->autologin=false;
                mystar->save_file();
                flag=false;
                break;
            case 5://网口断开状态
                n = new Notify::Notification("gMystar", "网络断开，请检查网络。。", "appointment-new");
                n->set_timeout(1000); //1 seconds
                n->show();
                flag=false;
            default:
                flag=true;
                break;
        }
    }
}
bool gMystar::on_key_press_event(GdkEventKey *ev)
{
    if(ev->type!=GDK_KEY_PRESS)
        return Window::on_key_press_event(ev);
    switch(ev->keyval)
    {
        case GDK_w:
            if(ev->state & GDK_CONTROL_MASK)
                //hide_window();
                hide();
        default:
            return Window::on_key_press_event(ev);
    }
    return true;
}
Mystar.h:
/*****************************************************
 *  Mystar.h
 *
 *  Copyright (C) 2009  csip(amoblin@gmail.com)
 *
 *  ChangeLog:
 *
 *  Description:
 *	Warning: this file should be in UTF-8.
 *  
 ******************************************************/
#include <stdlib.h>
#include <iostream>

//#include <stdio.h>
//#include <unistd.h>
//#include <string.h>
//#include <signal.h>
//#include <errno.h>
//#include <setjmp.h>
//#include <time.h>
//
#include <sys/types.h>
#include <sys/time.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <netinet/in.h>

//#include <arpa/inet.h>

#include <pcap.h>
#include <libnet.h>

#include "User.h"
#include "MD5.h"

#include <dbus/dbus-glib.h>
#include <libnm_glib.h>

#define DEBUG 1

#define FILTER_STR "ether[12:2]=0x888e and ether dst %02x:%02x:%02x:%02x:%02x:%02x"
#define BUFFER_SIZE 4096

using namespace std;

typedef union
{
	u_int32_t   ulValue;
	u_int8_t    btValue[4];
}ULONG_BYTEARRAY;

class Mystar
{
    public:
        Mystar();
        void authen();
        static void help();
        char *gbk2utf8(char *src);
        User user;
        bool autologin;
        int save_file();
        int get_status();
        void logout(int signo);
        libnm_glib_state nm_state;
        libnm_glib_ctx *nm_ctx;

    protected:
        void checkAndSetConfig();//finished!
        void init_file();
        int init_authen();
        int eapol();
        void send_username();
        void send_password();

        int authen_();
        int eapol_sendusername();
        int eapol_sendpassword();
        int eapol_search();

        void show_message(const char *message);

        //sendpacket.c
        int SendFindServerPacket(libnet_t *l);
        int SendNamePacket(libnet_t *l, const u_char *pkt_data);
        int SendPasswordPacket(libnet_t *l,const u_char *pkt_data);
        int SendEchoPacket(libnet_t *l,const u_char *pkt_data, ULONG_BYTEARRAY *m_serialNo);
        int SendEndCertPacket(libnet_t *l);


        //myerr.c
        void err_ret(const char *fmt, ...);
        void err_sys(const char *fmt, ...);
        void err_dump(const char *fmt, ...);
        void err_msg(const char *fmt, ...);
        void err_quit(const char *fmt, ...);
        void err_doit(int, const char*, va_list);


        //blog.h
        void InitializeBlog(const unsigned char *m_ip, const unsigned char *m_netmask,
                const unsigned char *m_netgate, const unsigned char *m_dns1);

        void FillNetParamater(unsigned char ForFill[]);

        unsigned char Alog(unsigned char BForAlog);
        void Blog();

        /*field
         *
         */

        MD5 md5;

        char nic[32];
        int intelligentReconnect;
        int echoInterval;
        int authenticationMode; //是哪种认证模式：0:标准 1:实达

        unsigned char localMAC[6];
        unsigned char destMAC[6];
        unsigned char m_ip[4];
        unsigned char m_netmask[4];
        unsigned char m_netgate[4];
        unsigned char m_dns1[4];

        //Mystar.cc
        libnet_t *l;    //指针，
        pcap_t *p;
        int p_fd;
        u_int32_t l_ip;
        u_int32_t p_netaddr, p_netmask;
        char filter_buf[256];
        struct bpf_program filter_code;

        struct libnet_ether_addr *l_ether_addr;

        char p_errbuf[PCAP_ERRBUF_SIZE];
        char l_errbuf[LIBNET_ERRBUF_SIZE];

        int isFirstPacketFromServer;
        //int packetCount_SentFindServer;
        //int packetCount_SentName;
        //int packetCount_SentPassword;
        //ULONG_BYTEARRAY m_serialNo;
        ULONG_BYTEARRAY m_key;

        volatile sig_atomic_t m_state;//0:disconect 1:found server 2:sending password 3:conect
        sigset_t sigset_full,sigset_zero;


        fd_set read_set;
        struct timespec timeout;
        const u_char *pkt_data;
        struct pcap_pkthdr *pkt_hdr;
        u_int16_t offset;
        ULONG_BYTEARRAY uTemp;
        int msgLen;
        char msgBuf[256];
        char *pmsgBuf;

        char *filename;
};
Mystar.cc:
/*****************************************************
 *  Mystar.cc
 *
 *  Copyright (C) 2009  csip(amoblin@gmail.com)
 *
 *  ChangeLog:
 *
 *  Description:
 *	Warning: this file should be in UTF-8.
 *  
 ******************************************************/
#include "Mystar.h"
#define MAXCOUNT 30
//using namespace Mystar;
Mystar::Mystar()
{
    nm_ctx = libnm_glib_init();
    static char file[20];
    strcpy(file,getenv("HOME"));
    strcat(file,"/.gMystarrc");
    filename = file;
    checkAndSetConfig();//finished!
}
void Mystar::authen()//原来用while的那个
{
    while(true)
    {
        nm_state = libnm_glib_get_network_state (nm_ctx);
        if(nm_state == LIBNM_NO_NETWORK_CONNECTION)
        {
            cout<<"请检查网络接口。。。"<<endl;
            sleep(4);
        }
        else if(nm_state == LIBNM_NO_DBUS || nm_state == LIBNM_NO_NETWORKMANAGER || nm_state == LIBNM_INVALID_CONTEXT || nm_state == LIBNM_ACTIVE_NETWORK_CONNECTION)
        {
            if(Mystar::init_authen()==0)
                eapol();
        }
    }
}
int Mystar::init_authen()
{
    l = NULL;
    p = NULL;
    isFirstPacketFromServer = 1;
    char l_errbuf[LIBNET_ERRBUF_SIZE];  //错误缓冲区？
    l = libnet_init(LIBNET_LINK, nic, l_errbuf);    //单数据包内存初始化及环境建立
    if(l==NULL)
        err_quit("libnet_init:%s\n", l_errbuf); //网卡初始化错误:找不到网卡或用户权限不够
    p = pcap_open_live(nic, 65536, 0, 500, p_errbuf);   //打开相应网卡并设置非混杂模式
    if(p==NULL)
    {
        err_msg("pcap_open_live:%s\n", p_errbuf);
        //goto err1
        libnet_destroy(l);
        return 1;
    }
    p_fd = pcap_fileno(p);  //返回savefile的表述符号
    l_ether_addr = libnet_get_hwaddr(l);
    if(l_ether_addr == NULL)
    {
        err_msg("unable to get local mac address :%s\n", libnet_geterror(l));
    }
    memcpy(localMAC, l_ether_addr, sizeof(localMAC));
#ifdef DEBUG
    printf("localmac为:");
    int i;
    for(i=0;i<6;i++)
    {
        printf("%2x ",*(localMAC+i));
    }
    printf("\n");
#endif

    if(user.get_fakeAddress()==NULL)
    {
        l_ip=libnet_get_ipaddr4(l);//指向ip的指针
        if(l_ip ==-1)
        {
            err_msg("unable to get ip address--ingored... :%s\n",libnet_geterror(l));
            l_ip=0;
        }
        memcpy(m_ip,&l_ip,sizeof(m_ip));
        printf("现在m_ip为:");
        for(i=0;i<3;i++)
        {
            printf("%d.",*(m_ip+i));
        }
        printf("%d\n",*(m_ip+i));
    }
    else
    {
        if( inet_pton(AF_INET,user.get_fakeAddress(),m_ip)<=0 )
            err_msg("invalid fakeAddress found in mystar.conf, ignored...\n");
        printf("设置m_ip为:");
        for(i=0;i<3;i++)
        {
            printf("%d.",*(m_ip+i));
        }
        printf("%d\n",*(m_ip+i));
    };

    if(pcap_lookupnet(nic,&p_netaddr,&p_netmask,p_errbuf)==-1)
    {
        err_msg("unable to get netmask--igored... %s\n",p_errbuf); p_netmask=0;}
        memcpy(m_netmask,&p_netmask,sizeof(m_netmask));

        InitializeBlog(m_ip,m_netmask,m_netgate,m_dns1); //see blog.c and bloc.h for details

        //set the filter. Here I'm sure filter_buf is big enough.
        snprintf(filter_buf,sizeof(filter_buf),FILTER_STR, localMAC[0],localMAC[1],
                localMAC[2],localMAC[3],localMAC[4],localMAC[5],localMAC[6]);
        if(pcap_compile(p, &filter_code,filter_buf, 0, p_netmask)==-1)
        {
            err_msg("pcap_compile(): %s", pcap_geterr(p));
            //goto err2; 
            pcap_close(p);
            libnet_destroy(l);
            return 1;
        }
        if(pcap_setfilter(p, &filter_code)==-1)
        {
            err_msg("pcap_setfilter(): %s", pcap_geterr(p));
            //goto err2;
            pcap_close(p);
            libnet_destroy(l);
            return 1;
        }
        pcap_freecode(&filter_code); // avoid  memory-leak

        //(void)signal(SIGINT,logout);  //We can exit with Ctrl+C
        (void)sigfillset(&sigset_full);
        (void)sigprocmask(SIG_BLOCK,&sigset_full,NULL); //block all signals.
        return 0;
}
int Mystar::eapol() //TODO: 2009-02-23开始
{
    /*
     * 返回值：
     *  0:成功
     *  1:错误  ,则终止程序
     *  2:超时  ,重连，到一阈值停止,这里应监测网口状态，是否连接？
     *  3:认证失败:服务器信息
     * */
#ifdef DEBUG
    printf("执行eapol协议\n");
    printf("先发一个包作开始：\n");
#endif
    m_state = 0;    //disconnecting state
    (void)SendFindServerPacket(l);	//the first time to search for server
    int packetCount_SentFindServer = 1;
    int packetCount_SentName = 0;
    int packetCount_SentPassword = 0;
    int i =1;
    while (true)
    {
#ifdef DEBUG
        printf("第%d次循环:\n",i);
#endif
        i++;
        (void) sigfillset(&sigset_full);
        (void) sigdelset(&sigset_full, SIGINT);
        FD_ZERO (&read_set);
        FD_SET (p_fd, &read_set);
        timeout.tv_sec = 1;
        timeout.tv_nsec = 0;	// 1 second

        //wait with all signals(except SIGINT) blocked.
        switch ( pselect(p_fd+1,&read_set,NULL,NULL,&timeout,&sigset_full) )
        {
            case -1: //Normally, this case should not happen since sig_intr() never returns!
                //error;
                pcap_close(p);
                libnet_destroy(l);
                return 1;
            case 0:  //timed out
                switch(m_state)
                {
                    case 0:
                        if(++packetCount_SentFindServer>MAXCOUNT)
                        {
                            puts("search server time out, Restarting authenticaton!");
                            return 2;
                        }
                        (void)SendFindServerPacket(l);
                        continue; //jump to next loop of while(1) to receive next packet
                    case 1:
                        if(++packetCount_SentName>MAXCOUNT)
                        {
                            puts("send username time out, Restarting authenticaton!");
                            return 2;
                        }
                        (void)SendNamePacket(l, pkt_data);
                        continue;
                    case 2:
                        if(++packetCount_SentPassword>MAXCOUNT)
                        {
                            puts("sent password time out, Restarting authenticaton!");
                            return 2;
                        }
                        (void)SendPasswordPacket(l, pkt_data);
                        continue;
                    default:         //error;
                        pcap_close(p);
                        libnet_destroy(l);
                        return 1;
                }
        }

        //Here return value of pselect must be 1

        if((pcap_next_ex(p,&pkt_hdr,&pkt_data))!=1) continue;

        //收到的第二个及其以后的有效packet的源MAC必须等于头次收到的有效分组的源MAC
        if ((!isFirstPacketFromServer)&&(memcmp(destMAC,pkt_data+6,6)!=0)) continue;

        //received a packet successfully. for convenience, SUPPOSE it's the RIGHT packet!! but maybe WRONG!!
        //for example, we have NEVER vefified the length of packet, fancying the packet's length is 0x11 ?!

        /*服务器端请求
         *{
         * 0x00-0x05    数据目的MAC 
         * 0x06-0x0b    数据源MAC   
         * 0x0c-0x0d    协议类型          88 8e代表802.1x协议
         * 0x0e         版本号      
         * 0x0f         帧类型      
         * 0x10-0x11    802.1x数据长度    
         * 0x12                           01表示请求,03表示认证成功,04表示认证失败
         * 0x13         Identity          1   提供给回应包    link1
         * 0x14-0x15    EAP协议数据长度   大多数情况下和8021.x协议数据长度一样
         * 0x16         请求类型          01表示请求用户名，04表示请求密码
         * 0x17         密钥长度
         * 0x18-        密钥
         *}*/

        /* EAPOL Request,Identity [RFC 3748]
           0000  00 16 36 c9 ba 3c 00 d0 f8 d9 f1 04 88 8e 01 00   ..6..<..........
           0010  00 05 01 51 00 05 01 00 00 00 00 00 00 00 00 00   ...Q............
           0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
           0030  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
           */
        /*服务器端请求用户名
         *{
         * 0x00-0x05    数据目的MAC 001636c9ba3c是我的电脑的MAC地址
         * 0x06-0x0b    数据源MAC   00d0f8d9f104是我们计算中心AAA的MAC地址
         * 0x0c-0x0d    协议类型    88 8e代表802.1x协议
         * 0x0e         版本号      01
         * 0x0f         帧类型      00
         * 0x10-0x11    数据长度    这里是5
         * 0x12                     01表示请求
         * 0x13         Identity    5x16+1=81   提供给回应包    link1
         * 0x14-0x15    数据长度    重复0x10-0x11字段值
         * 0x16         请求类型    01表示请求用户名
         *}*/

        /* EAP Request,MD5-Challenge
           0000  00 16 36 c9 ba 3c 00 d0 f8 d9 f1 04 88 8e 01 00   ..6..<..........
           0010  00 16 01 53 00 16 04 10 18 55 3b b2 96 11 1b fd   ...S.....U;.....
           0020  4e c5 2e 56 2e 8a 97 66 00 00 00 00 00 00 00 00   N..V...f........
           0030  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
           */
        /* 服务器端请求密码
         * {
         * 0x00-0x05    数据目的MAC 001636c9ba3c是我电脑的MAC地址
         * 0x06-0x0b    数据源MAC   00d0f8d9f104是我们计算中心AAA的MAC地址
         * 0x0c-0x0d    协议类型    88 8e代表802.1x协议
         * 0x0e         版本号      01
         * 0x0f         帧类型      00
         * 0x10-0x11    数据长度    这里是22字节
         * 0x12                     01表示请求
         * 0x13         Identity    53   提供给回应包    link1
         * 0x14-0x15    数据长度    重复0x10-0x11字段值
         * 0x16         请求类型    04表示请求密码
         * 0x17         密钥长度    这里密钥长度为16字节
         * 0x18-        密钥        密钥为18553bb296111bfd4ec52e562e8a9766
         * }*/

        /* EAP Success
           0000  00 16 36 c9 ba 3c 00 d0 f8 d9 f1 04 88 8e 01 00   ..6..<..........
           0010  00 f9 03 53 00 04 00 00 13 11 00 65 0d 0a d3 c9   ...S.......e....
           0020  d3 da d1 a7 d0 a3 77 73 75 73 b7 fe ce f1 c6 f7   ......wsus......
           0030  d3 f2 c3 fb b8 fc d0 c2 a3 ac c7 eb d3 c3 bb a7   ................
           0040  b5 c7 c2 bd 77 73 75 73 2e 62 69 73 74 75 2e 65   ....wsus.bistu.e
           0050  64 75 2e 63 6e d6 d8 d0 c2 cf c2 d4 d8 d4 cb d0   du.cn...........
           0060  d0 cf e0 d3 a6 b5 c4 d7 a2 b2 e1 b1 ed ce c4 bc   ................
           0070  fe a3 a8 d6 d8 c6 f0 ba f3 c9 fa d0 a7 a3 a9 21   ...............!
           0080  0a 00 00 13 11 00 49 00 00 00 00 00 00 00 00 00   ......I.........
           0090  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
           00a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
           00b0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
           00c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
           00d0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
           00e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
           00f0  00 00 13 11 01 01 00 00 13 11 01 01 ff ff 37 77   ..............7w
           0100  af 7f ff ff eb cd ff ff ff d7 ff                  ...........
           */
        /* 认证成功
         *{
         * 0x00-0x05    数据目的MAC 001636c9ba3c是我电脑的MAC地址
         * 0x06-0x0b    数据源MAC   00d0f8d9f104是我们计算中心AAA的MAC地址
         * 0x0c-0x0d    协议类型    88 8e代表802.1x协议
         * 0x0e         版本号      01
         * 0x0f         帧类型      00
         * 0x10-0x11    数据长度    15x16+9=249
         * 0x12                     03表示认证成功
         * 0x13         Identity    53   提供给回应包    link2
         * 0x14-0x15    这里不是数据长度了
         * 0x           序列号      保持激活用
         *}*/

        switch( pkt_data[0x12] )        //分析EAP包类型
        {
            case 0x01:        
                switch( pkt_data[0x16] )
                {
                    case 0x01:   //type 1,以用户名应答
                        /* 服务器端请求用户名   2:EAP Request
                         * {
                         * 0x00-0x05
                         * 0x06-0x0b
                         * 0x0c-0x0d    协议类型    88 8e
                         * 0x0e         版本号      01
                         * 0x0f         帧类型      00
                         * 0x10-0x11    数据长度
                         * 0x12                     01表示请求
                         * 0x13         Identity    1   提供给回应包    link1
                         * 0x14-0x15    数据长度    重复0x10-0x11字段值
                         * 0x16         请求类型    01表示请求用户名
                         * }*/
                        if(m_state!=0)
                            continue;
                        cout<<"csip\n";
                        show_message("Server found, requesting user name...\n");
                        send_username();    //  3:EAP Response
                        ++packetCount_SentName;
                        break;
                    case 0x04:   //type 4,挑战，以MD5计算得到的值应答   6:Challenge Request
                        /* 服务器端请求密码     2:EAP Request
                         * {
                         * 0x00-0x05
                         * 0x06-0x0b
                         * 0x0c-0x0d    协议类型    88 8e
                         * 0x0e         版本号      01
                         * 0x0f         帧类型      00
                         * 0x10-0x11    数据长度
                         * 0x12                     01表示请求
                         * 0x13         Identity    1   提供给回应包    link1
                         * 0x14-0x15    数据长度    重复0x10-0x11字段值
                         * 0x16         请求类型    04表示请求密码
                         * 0x17         密钥长度
                         * 0x18-        密钥
                         * }*/
                        if(m_state!=1)
                            continue;
                        show_message("User name valid, requesting password...\n");
                        ++packetCount_SentPassword;
                        send_password();    //  7:EAP Challenge Response
                        break;
                }
                break;
            case 0x03:         
                /* 认证成功     10:EAP Success
                 *{
                 * 0x00-0x05
                 * 0x06-0x0b
                 * 0x0c-0x0d    协议类型    88 8e
                 * 0x0e         版本号      01
                 * 0x0f         帧类型      00
                 * 0x10-0x11    数据长度
                 * 0x12                     03表示认证成功
                 * 0x13         Identity    1   提供给回应包    link2
                 * 0x14-0x15    数据长度    重复0x10-0x11字段值
                 * 0x           序列号      保持激活用
                 *}*/
                if(m_state!=2)
                    continue;
                m_state=3;
                show_message("@@ Password valid, authentication SUCCESS!!! :)\n");
                if (echoInterval<=0)  //user has echo disabled
                {
                    //goto done; 
                    printf("echoInterval:%d",echoInterval);
                    pcap_close(p); libnet_destroy(l);
                    return 1;
                }
                //uTemp.ulValue = *(((u_long *)(pkt_data+0x9d)));
                offset=ntohs( *((u_int16_t*)(pkt_data+0x10)) );
                uTemp.ulValue = *((u_int32_t *)(pkt_data+(0x11+offset)-0x08));
                m_key.btValue[0] = Alog(uTemp.btValue[3]);
                m_key.btValue[1] = Alog(uTemp.btValue[2]);
                m_key.btValue[2] = Alog(uTemp.btValue[1]);
                m_key.btValue[3] = Alog(uTemp.btValue[0]);

                //unblock SIGINT, so we can exit with Ctrl+C
                (void)sigemptyset(&sigset_zero);
                (void)sigaddset(&sigset_zero,SIGINT);
                (void)sigprocmask(SIG_UNBLOCK,&sigset_zero,NULL);
                // continue echoing
                show_message("Keeping sending echo...\n");

                ULONG_BYTEARRAY m_serialNo;
                m_serialNo.ulValue = 0x1000002a;//the initial serial number, a magic number!
                while(true)
                {
                    nm_state = libnm_glib_get_network_state (nm_ctx);
                    if(nm_state == LIBNM_NO_NETWORK_CONNECTION)
                        break;
                    else
                    {
                        if(SendEchoPacket(l, pkt_data, &m_serialNo)!=0)
                            break;
                        sleep(echoInterval);
                    }
                }
                //goto err2; //this should never happen.
                pcap_close(p);
                libnet_destroy(l);
                return 1;
                break;
            case 0x04:        //认证失败(用户名或密码错误/不在上网时段内/重复上网等)    16
                /* 认证失败 10:EAP Failed
                 *{
                 * 0x00-0x05
                 * 0x06-0x0b
                 * 0x0c-0x0d    协议类型    88 8e
                 * 0x0e         版本号      01
                 * 0x0f         帧类型      00
                 * 0x10-0x11    数据长度
                 * 0x12                     04表示认证失败
                 * 0x13         Identity    1   提供给回应包    link2
                 * 0x14-0x15    数据长度    重复0x10-0x11字段值
                 *}*/
                if((m_state==0)||(m_state==3)) continue;
                m_state=0;
                msgLen=ntohs( *((u_int16_t*)(pkt_data+0x10)) )-10;
                char *msgBuf_utf8=NULL;
                if (msgLen>0)
                {
                    if(msgLen>=(sizeof(msgBuf)-1)) msgLen=sizeof(msgBuf)-1;
                    memset(msgBuf,'\0',sizeof(msgBuf));
                    memcpy(msgBuf, pkt_data+0x1c, msgLen);
                    pmsgBuf=msgBuf;
                    //remove the leanding "\r\n" which seems alway to exist!
                    if((msgLen>2)&&(msgBuf[0]==0xd)&&(msgBuf[1]==0xa)) pmsgBuf+=2;

#ifdef DEBUG
                    /*
                       char *msgBuf_p=msgBuf;
                       printf("服务器返回的信息(十六进制码格式)为：");
                       while(*msgBuf_p)
                       {

                       printf("0x%2x,",(unsigned)*msgBuf_p%256);
                       msgBuf_p++;
                       }
                       printf("\n");
                       printf("服务器返回的信息(GBK编码格式)为：%s\n",msgBuf);
                       */
#endif
                    /* 关于编码的注释
                     *{
                     * GBK编码，中文两字节，英文一字节
                     * 根据每字节首位来判断:
                     * 若为0,则表示余下七位表示ASCII字符
                     * 若为1,则表示接下来的两个字节表示一个汉字
                     *
                     * 0    0000
                     * 1    0001
                     * 2    0010
                     * 3    0011
                     * 4    0100
                     * 5    0101
                     * 6    0110
                     * 7    0111
                     * 8    1000
                     * 9    1001
                     * a    1010
                     * b    1011
                     * c    1100
                     * d    1101
                     * e    1110
                     * f    1111
                     *
                     *0x d,0x a,0x49,0x50,0xb5,0xd8,0xd6,0xb7,
                     *  \n   \r   I    P      地        址        
                     *
                     * \n   0000 1101
                     * \r   0000 1010
                     * I    0100 1001
                     * P    0101 0000
                     * 地   1011 0101 1101 1000
                     * 址   1101 0110 1011 0111
                     *
                     *
                     *0xb0,0xf3,0xb6,0xa8,0xb4,0xed,0xce,0xf3,0x21
                     *   绑        定        错        误     !
                     *0x d,0x a,0xd2,0xd1,0xb4,0xef,0xb5,0xbd,0xcd,0xac,0xca,0xb1,0xd4,0xda,
                     *              已        达        到        同        时        在
                     0xcf,0xdf,0xd3,0xc3,0xbb,0xa7,0xca,0xfd,0xc1,0xbf,0xc9,0xcf,0xcf,0xde,0x21
                     *  线        用        户        数        量        上        限      !
                     *0x d,0x a,0xd3,0xc3,0xbb,0xa7,0xb2,0xbb,0xb4,0xe6,0xd4,0xda,
                     *              用        户        不        存        在
                     *0xbb,0xf2,0xc3,0xdc,0xc2,0xeb,0xb4,0xed,0xce,0xf3,0x21,
                     *    或        密       码         错        误      !
                     *0x d,0x a,0xb2,0xbb,0xd4,0xda,0xc8,0xcf,0xd6,0xa4,
                     *              不        在        认        证
                     0xca,0xb1,0xb6,0xce,0xc4,0xda,0x21
                     *   时        段        内      !
                     * 
                     *}*/
                    msgBuf_utf8=gbk2utf8(msgBuf);//转换成功，但显示不出来。。。

                    //ConvertGBKToUtf8(msgBuf_utf8,msgBuf);
                    // gb2312-->utf-8
                    //CodeConverter cc2 = CodeConverter("gb2312","utf-8");//这两行出现段错误
                    //cc2.convert(msgBuf,strlen(msgBuf),msgBuf_utf8,255);

                }
                else //这个估计是服务器告知静默或确认断网的包
                {
                    pmsgBuf=NULL;
                }
                //fprintf(stdout,"@@ Authenticaton failed!!! :(%s\n",pmsgBuf);
                //fprintf(stdout,"@@ Authenticaton failed!!! :(%s\n",msgBuf_utf8);
                printf("@@ Authenticaton failed!!! :(%s\n",msgBuf_utf8);
#ifdef DEBUG
                //printf("认证失败，返回信息转化为UTF8编码后为：%s\n",msgBuf_utf8);
#endif
                (void)SendEndCertPacket(l); //  13:EAPOL Logoff    

                //return eapol();
                return 3;

                break; //should never come here

        }// end switch
    }// end while
}
void Mystar::send_username()
{
    m_state = 1;
    if (isFirstPacketFromServer)	//获得服务器的MAC地址
    {
        memcpy (destMAC, pkt_data + 6, 6);
        isFirstPacketFromServer = 0;
    }
#ifdef DEBUG
    fputs("发送用户包",stdout);
#endif
    (void) SendNamePacket(l, pkt_data);
}
void Mystar::send_password()
{
    m_state = 2;
#ifdef DEBUG
    fputs("发送密码包",stdout);
#endif
    (void)SendPasswordPacket(l, pkt_data);
}
void Mystar::logout(int signo)    //中断信号设置;
{
    char l_errbuf[LIBNET_ERRBUF_SIZE];
    if(m_state==3)
    {
        l=libnet_init(LIBNET_LINK, nic,l_errbuf);
        if( l == NULL)
            _exit(0);
        (void)SendEndCertPacket(l);
        libnet_destroy(l);  //资源释放
    }
    //_exit(0);
}
void Mystar::help()
{
    fputs("--nogui  use command line interface\n",stdout);
    fputs("--help   show this help\n",stdout);
}
void Mystar::show_message(const char *message)
{
    printf("%s", message);
}

int Mystar::authen_(void)
{
    if(init_authen()==0)
    {
        int state;
        while(eapol_search());
        while(eapol_sendusername());
        while(state=eapol_sendpassword())
        {
            if(state==3)
                return 1;
        }
    }
    else
        return 1;
}
int Mystar::eapol_search() //TODO:
{
    /*
     * 返回值：
     *  0:成功
     *  1:错误  ,则终止程序
     *  2:超时  ,重连，到一阈值停止,这里应监测网口状态，是否连接？
     *  3:包错误
     * */
    (void)SendFindServerPacket(l);	//the first time to search for server   第一个发送的包包

    (void) sigfillset(&sigset_full);
    (void) sigdelset(&sigset_full, SIGINT);
    FD_ZERO (&read_set);
    FD_SET (p_fd, &read_set);
    timeout.tv_sec = 1;
    timeout.tv_nsec = 0;	// 1 second

    //wait with all signals(except SIGINT) blocked.
    switch ( pselect(p_fd+1,&read_set,NULL,NULL,&timeout,&sigset_full) )
    {
        case -1: //Normally, this case should not happen since sig_intr() never returns!
            //error;
            pcap_close(p);
            libnet_destroy(l);
            return 1;
        case 0:  //timed out
            return 2;
    }

    if((pcap_next_ex(p,&pkt_hdr,&pkt_data))!=1) return 3;   //?

    if ((!isFirstPacketFromServer)&&(memcmp(destMAC,pkt_data+6,6)!=0)) return 3;

    if( ( pkt_data[0x12] == 0x01 ) && ( pkt_data[0x16] == 0x01 ) )
    {
        fputs ("@@ Server found, requesting user name...\n", stdout);
        return 0;
    }
    else
        return 3;
}
int Mystar::eapol_sendusername() //TODO:找到EAPoL start，避免死循环   2009-02-23开始
{
    /*
     * 返回值：
     *  0:成功
     *  1:错误  ,则终止程序
     *  2:超时  ,重连，到一阈值停止,这里应监测网口状态，是否连接？
     *  3:包错误
     * */
    send_username();
    (void) sigfillset(&sigset_full);
    (void) sigdelset(&sigset_full, SIGINT);
    FD_ZERO (&read_set);
    FD_SET (p_fd, &read_set);
    timeout.tv_sec = 1;
    timeout.tv_nsec = 0;	// 1 second

    //wait with all signals(except SIGINT) blocked.
    switch ( pselect(p_fd+1,&read_set,NULL,NULL,&timeout,&sigset_full) )
    {
        case -1: //Normally, this case should not happen since sig_intr() never returns!
            //error;
            pcap_close(p);
            libnet_destroy(l);
            return 1;
        case 0:  //timed out
            return 2;
    }

    //Here return value of pselect must be 1

    if((pcap_next_ex(p,&pkt_hdr,&pkt_data))!=1) return 3;   //?

    //收到的第二个及其以后的有效packet的源MAC必须等于头次收到的有效分组的源MAC
    if ((!isFirstPacketFromServer)&&(memcmp(destMAC,pkt_data+6,6)!=0)) return 3;

    //received a packet successfully. for convenience, SUPPOSE it's the RIGHT packet!! but maybe WRONG!!
    //for example, we have NEVER vefified the length of packet, fancying the packet's length is 0x11 ?!

    if( ( pkt_data[0x12] == 0x01 ) && ( pkt_data[0x16] == 0x04 ) )
    {
        fputs ("@@ User name valid, requesting password...\n", stdout);
        return 0;
    }
    else
        return 3;
}
int Mystar::eapol_sendpassword() //TODO:找到EAPoL start，避免死循环   2009-02-23开始
{
    /*
     * 返回值：
     *  0:成功
     *  1:错误  ,则终止程序
     *  2:超时  ,重连，到一阈值停止,这里应监测网口状态，是否连接？
     *  3:包错误
     * */
    send_password();
    (void) sigfillset(&sigset_full);
    (void) sigdelset(&sigset_full, SIGINT);
    FD_ZERO (&read_set);
    FD_SET (p_fd, &read_set);
    timeout.tv_sec = 1;
    timeout.tv_nsec = 0;	// 1 second

    //wait with all signals(except SIGINT) blocked.
    switch ( pselect(p_fd+1,&read_set,NULL,NULL,&timeout,&sigset_full) )
    {
        case -1: //Normally, this case should not happen since sig_intr() never returns!
            //error;
            pcap_close(p);
            libnet_destroy(l);
            return 1;
        case 0:  //timed out
            return 2;
    }

    //Here return value of pselect must be 1

    if((pcap_next_ex(p,&pkt_hdr,&pkt_data))!=1) return 3;   //?

    //收到的第二个及其以后的有效packet的源MAC必须等于头次收到的有效分组的源MAC
    if ((!isFirstPacketFromServer)&&(memcmp(destMAC,pkt_data+6,6)!=0)) return 3;

    //received a packet successfully. for convenience, SUPPOSE it's the RIGHT packet!! but maybe WRONG!!
    //for example, we have NEVER vefified the length of packet, fancying the packet's length is 0x11 ?!

    if( pkt_data[0x12] == 0x03 )
    {
        fputs("@@ Password valid, authentication SUCCESS!!! :)\n",stdout);
        if (echoInterval<=0)  //user has echo disabled
        {
            //goto done; 
            printf("echoInterval:%d",echoInterval);
            pcap_close(p); libnet_destroy(l);
            return 1;
        }

        //uTemp.ulValue = *(((u_long *)(pkt_data+0x9d)));
        offset=ntohs( *((u_int16_t*)(pkt_data+0x10)) );
        uTemp.ulValue = *((u_int32_t *)(pkt_data+(0x11+offset)-0x08));
        m_key.btValue[0] = Alog(uTemp.btValue[3]);
        m_key.btValue[1] = Alog(uTemp.btValue[2]);
        m_key.btValue[2] = Alog(uTemp.btValue[1]);
        m_key.btValue[3] = Alog(uTemp.btValue[0]);

        //unblock SIGINT, so we can exit with Ctrl+C
        (void)sigemptyset(&sigset_zero);
        (void)sigaddset(&sigset_zero,SIGINT);
        (void)sigprocmask(SIG_UNBLOCK,&sigset_zero,NULL);
        // continue echoing
        fputs("Keeping sending echo... 保持连接了。。。\n",stdout);
        ULONG_BYTEARRAY m_serialNo;
        m_serialNo.ulValue = 0x1000002a;	//the initial serial number, a magic number!
        while(SendEchoPacket(l,pkt_data, &m_serialNo)==0)
            sleep(echoInterval);
        //goto err2; //this should never happen.
        pcap_close(p);
        libnet_destroy(l);
        return 1;
    }
    else if( pkt_data[0x12] == 0x04 )
    {
        msgLen=ntohs( *((u_int16_t*)(pkt_data+0x10)) )-10;
        char *msgBuf_utf8=NULL;
        if (msgLen>0)
        {
            if(msgLen>=(sizeof(msgBuf)-1)) msgLen=sizeof(msgBuf)-1;
            memset(msgBuf,'\0',sizeof(msgBuf));
            memcpy(msgBuf, pkt_data+0x1c, msgLen);
            pmsgBuf=msgBuf;
            //remove the leanding "\r\n" which seems alway to exist!
            if((msgLen>2)&&(msgBuf[0]==0xd)&&(msgBuf[1]==0xa)) pmsgBuf+=2;
        }
        else //这个估计是服务器告知静默或确认断网的包
        {
            pmsgBuf=NULL;
        }
        //fprintf(stdout,"@@ Authenticaton failed!!! :(%s\n",pmsgBuf);
        //fprintf(stdout,"@@ Authenticaton failed!!! :(%s\n",msgBuf_utf8);
        printf("@@ Authenticaton failed!!! :(%s\n",msgBuf_utf8);
        (void)SendEndCertPacket(l); //  13:EAPOL Logoff    
        return 3;
    }
}
int Mystar::get_status()
{
    nm_state = libnm_glib_get_network_state (nm_ctx);
    if(nm_state == LIBNM_NO_NETWORK_CONNECTION)
    {
        return 5;
    }
    else
        return m_state;
}
User.h:
/**************************************************
 *  User.h
 *
 *  Copyright (C) 2009  csip(amoblin@gmail.com)
 *
 *  ChangeLog:
 *
 *  Description:
 *	Warning: this file should be in UTF-8.
 *  
 **************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iostream>
using namespace std;
class User  //用户信息
{
    public:
        User(char *username, char *password, char *nickname, char *fakeAddress);
        User();
        void set_username(const char *username);
        void set_password(const char *password);
        void set_nickname(const char *nickname);
        void set_fakeAddress(const char *fakeAddress);
        char *get_username();
        char *get_password();
        char *get_nickname();
        char *get_fakeAddress();
    private:
            char username[32];
            char password[32];
            char nickname[32];
            char fakeAddress[32];
};
User.cc:
/****************************************************
 *  User.cc
 *
 *  Copyright (C) 2009  csip(amoblin@gmail.com)
 *
 *  ChangeLog:
 *
 *  Description:
 *	Warning: this file should be in UTF-8.
 *  
 *****************************************************/
#include "User.h"
User::User(char *username, char *password, char *nickname, char *fakeAddress)
{
    set_username(username);
    set_password(password);
    set_nickname(nickname);
    set_fakeAddress(fakeAddress);
}
User::User()
{
    memset(username,'\0',32);
    memset(password,'\0',32);
    memset(nickname,'\0',32);
    memset(fakeAddress,'\0',32);
}
void User::set_username(const char *username)
{
    if( (username == NULL) || (username[0] == 0) )
        cout<<"invalid name found in gMystarrc!\n"<<endl;
    else
    {
        strcpy(this->username,username);
        cout<<"username is "<<username<<endl;
    }
}
void User::set_password(const char *password)
{
    if( (password == NULL) || (password[0] == 0) )
        cout<<"invalid password found in gMystarrc!\n";
    else
    {
        strcpy(this->password,password);
        cout<<"password is "<<password<<endl;
        cout<<"here!"<<endl;
    }
}
void User::set_nickname(const char *nickname)
{
    if( (nickname== NULL) || (nickname[0] == 0) )
        cout<<"invalid nickname found in gMystarrc!\n";
    else
    {
        strcpy(this->nickname,nickname);
        cout<<"nickname is "<<nickname<<endl;
    }
}
void User::set_fakeAddress(const char *fakeAddress)
{
    if( (fakeAddress == NULL) || (fakeAddress[0] == 0) )
        cout<<"invalid fakeAddress found in gMystarrc!\n";
    else
    {
        strcpy(this->fakeAddress,fakeAddress);
        cout<<"fakeAddress is "<<fakeAddress<<endl;
    }
}
char *User::get_username()
{
    return username;
}
char *User::get_password()
{
    return password;
}
char *User::get_nickname()
{
    return nickname;
}
char *User::get_fakeAddress()
{
    return fakeAddress;
}
MD5.h:
              /* MD5.H - header file for MD5.C */

/* 
Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.

License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.

License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.*/

/* POINTER defines a generic pointer type */
typedef unsigned char *POINTER;

/* UINT2 defines a two byte word */
typedef unsigned short int UINT2;

/* UINT4 defines a four byte word */
typedef unsigned long int UINT4;

/* MD5 context. */
typedef struct 
{
  UINT4 state[4];                                   /* state (ABCD) */
  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
  unsigned char buffer[64];                         /* input buffer */
} MD5_CTX;

class MD5
{
    public:
        MD5();
        unsigned char* ComputeHash(unsigned char *src,int len);
        //field:
        unsigned char md5Data[256];
        unsigned char *md5Dig;
        int md5Len;

    protected:
        void MD5Init(MD5_CTX * context);
        void MD5Update(MD5_CTX *context, unsigned char *input, unsigned int inputLen);
        void MD5Final(unsigned char digest[16], MD5_CTX *context);

        void MD5Transform(UINT4 state[4], unsigned char block[64]);
        void Encode(unsigned char *output, UINT4 *input, unsigned int len);
        void Decode (UINT4 *output, unsigned char *input, unsigned int len);
        void MD5_memcpy (POINTER output, POINTER input, unsigned int len);
        void MD5_memset (POINTER output,int value,unsigned int len);



};
MD5.cc:
/* MD5.c - an implementation of md5 algorithm */

/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.

License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.

License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.
 */

/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm */

/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.

License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.

License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.
 */

#include "MD5.h"

/* Constants for MD5Transform routine. */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

/* F, G, H and I are basic MD5 functions.
 */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
Rotation is separate from addition to prevent recomputation.
 */
#define FF(a, b, c, d, x, s, ac) { \
 (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) { \
 (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) { \
 (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) { \
 (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }

MD5::MD5()
{
}

/* MD5 initialization. Begins an MD5 operation, writing a new context.
 */
void MD5::MD5Init (MD5_CTX * context)
{
  context->count[0] = context->count[1] = 0;
  /* Load magic initialization constants.
*/
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->state[3] = 0x10325476;
}

/* MD5 block update operation. Continues an MD5 message-digest
  operation, processing another message block, and updating the
  context.
 */
void MD5::MD5Update (MD5_CTX *context, unsigned char *input, unsigned int inputLen)
{
  unsigned int i, index, partLen;

  /* Compute number of bytes mod 64 */
  index = (unsigned int)((context->count[0] >> 3) & 0x3F);

  /* Update number of bits */
  if ((context->count[0] += ((UINT4)inputLen << 3))
   < ((UINT4)inputLen << 3))
 context->count[1]++;
  context->count[1] += ((UINT4)inputLen >> 29);

  partLen = 64 - index;

  /* Transform as many times as possible.
*/
  if (inputLen >= partLen) {
 MD5_memcpy
   ((POINTER)&context->buffer[index], (POINTER)input, partLen);
 MD5Transform (context->state, context->buffer);

 for (i = partLen; i + 63 < inputLen; i += 64)
   MD5Transform (context->state, &input[i]);

 index = 0;
  }
  else
 i = 0;

  /* Buffer remaining input */
  MD5_memcpy
 ((POINTER)&context->buffer[index], (POINTER)&input[i],
  inputLen-i);
}

/* MD5 finalization. Ends an MD5 message-digest operation, writing the
  the message digest and zeroizing the context.
 */
void MD5::MD5Final (unsigned char digest[16], MD5_CTX *context)
{
  unsigned char bits[8];
  unsigned int index, padLen;

  /* Save number of bits */
  Encode (bits, context->count, 8);

  /* Pad out to 56 mod 64.
*/
  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
  padLen = (index < 56) ? (56 - index) : (120 - index);
  MD5Update (context, PADDING, padLen);

  /* Append length (before padding) */
  MD5Update (context, bits, 8);

  /* Store state in digest */
  Encode (digest, context->state, 16);

  /* Zeroize sensitive information.
*/
  MD5_memset ((POINTER)context, 0, sizeof (*context));
}

unsigned char* MD5::ComputeHash(unsigned char* src,int len)
{
   MD5_CTX context;
   static unsigned char digest[16];

   MD5Init(&context);
   MD5Update(&context, src, len);
   MD5Final(digest, &context);

   return digest;
}

/* MD5 basic transformation. Transforms state based on block.
 */
void MD5::MD5Transform (UINT4 state[4],unsigned char block[64])
{
  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];

  Decode (x, block, 64);

  /* Round 1 */
  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
  FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
  FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
  FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
  FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
  FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
  FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
  FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
  FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
  FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
  FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */

 /* Round 2 */
  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
  GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
  GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
  GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */
  GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
  GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */


  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
  GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
  HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
  HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
  HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
  HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
  HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
  HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
  HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
  II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
  II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
  II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
  II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
  II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
  II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
  II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
  II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
  II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
  II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
  II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;

  /* Zeroize sensitive information.

*/
  MD5_memset ((POINTER)x, 0, sizeof (x));
}

/* Encodes input (UINT4) into output (unsigned char). Assumes len is
  a multiple of 4.
 */
void MD5::Encode(unsigned char *output, UINT4 *input, unsigned int len)
{
  unsigned int i, j;

  for (i = 0, j = 0; j < len; i++, j += 4) {
 output[j] = (unsigned char)(input[i] & 0xff);
 output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
 output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
 output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
  }
}

/* Decodes input (unsigned char) into output (UINT4). Assumes len is
  a multiple of 4.
 */
void MD5::Decode (UINT4 *output, unsigned char *input, unsigned int len)
{
  unsigned int i, j;

  for (i = 0, j = 0; j < len; i++, j += 4)
 output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
   (((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
}

/* Note: Replace "for loop" with standard memcpy if possible.
 */

void MD5::MD5_memcpy (POINTER output, POINTER input, unsigned int len)
{
  unsigned int i;

  for (i = 0; i < len; i++)

 output[i] = input[i];
}

/* Note: Replace "for loop" with standard memset if possible.
 */

void MD5::MD5_memset (POINTER output,int value,unsigned int len)
{
	unsigned int i;
	for (i = 0; i < len; i++)
		((char *)output)[i] = (char)value;
}
checkAndSetConfig.cc:
/****************************************************
 *  checkAndSetConfig.cc
 *
 *  Copyright (C) 2009  csip(amoblin@gmail.com)
 *
 *  ChangeLog:
 *
 *  Description:
 *	Warning: this file should be in UTF-8.
 *  
 ****************************************************/
#include "Mystar.h"
#include "tinyxml/tinyxml.h"
#include "tinyxml/tinystr.h"

void Mystar::checkAndSetConfig()
{
    TiXmlDocument mystarconf(filename);
    if(mystarconf.LoadFile())
    {
        cout<<"找到配置文件。。。\n";
    }
    else
    {
        init_file();
        return;
    }
    TiXmlElement* mystarroot = mystarconf.RootElement();
    if(mystarroot == NULL)
        return;
    TiXmlElement* UsersElement = mystarroot->FirstChildElement();
    if(UsersElement==NULL)
        return;
    TiXmlElement* UserElement = UsersElement->FirstChildElement();
    if(UserElement==NULL)
        return;
    TiXmlElement *nickname = UserElement->FirstChildElement();
    TiXmlElement *username = nickname->NextSiblingElement();
    TiXmlElement *password = username->NextSiblingElement();
    TiXmlElement *fakeAddress = password->NextSiblingElement();

    user.set_nickname(nickname->GetText());
    user.set_username(username->GetText());
    user.set_password(password->GetText());
    user.set_fakeAddress(fakeAddress->GetText());

    TiXmlElement *config = UsersElement->NextSiblingElement();

    TiXmlElement *autologinElement = config->FirstChildElement();
    TiXmlElement *authen = autologinElement->NextSiblingElement();
    cout<<"success!"<<endl;
    TiXmlElement *nicElement = authen->NextSiblingElement();
    cout<<"success!"<<endl;
    TiXmlElement *echo = nicElement->NextSiblingElement();

    strncpy(nic, nicElement->GetText(), sizeof(nic)-1);
    nic[sizeof(nic)-1]=0;

    if(!strcmp(autologinElement->GetText(),"true"))
        autologin = true;
    else
        autologin = false;
    //autologin=autologinElement->GetText();
    cout<<"autologin is:"<<autologin<<endl;
#ifdef DEBUG
    printf("nic is: %s\n",nic);
#endif

    echoInterval = atoi(echo->GetText());
#ifdef DEBUG
    printf("echoInterval is: %d\n",echoInterval);
#endif


}
void Mystar::init_file()
{
    //创建一个XML的文档对象。
    TiXmlDocument *myDocument = new TiXmlDocument();
    TiXmlDeclaration *title = new TiXmlDeclaration("1.0","utf-8","yes");
    myDocument->LinkEndChild(title);

    TiXmlComment *comment = new TiXmlComment("update the information below");
    myDocument->LinkEndChild(comment);

    //创建一个根元素并连接。
    TiXmlElement *RootElement = new TiXmlElement("mystar"); myDocument->LinkEndChild(RootElement);
    //创建一个users元素并连接。
    TiXmlElement *UsersElement = new TiXmlElement("users");
    RootElement->LinkEndChild(UsersElement);
    //创建一个user元素并连接。
    TiXmlElement *userElement = new TiXmlElement("user");
    UsersElement->LinkEndChild(userElement);
    //设置user元素的属性。
    userElement->SetAttribute("active", "true");

    TiXmlElement *tempElement = new TiXmlElement("nickname");
    userElement->LinkEndChild(tempElement);
    TiXmlText *tempContent = new TiXmlText("your nick name");
    tempElement->LinkEndChild(tempContent);

    tempElement = new TiXmlElement("name");
    userElement->LinkEndChild(tempElement);
    tempContent = new TiXmlText("your user name");
    tempElement->LinkEndChild(tempContent);

    tempElement = new TiXmlElement("password");
    userElement->LinkEndChild(tempElement);
    tempContent = new TiXmlText("your password");
    tempElement->LinkEndChild(tempContent);

    tempElement = new TiXmlElement("fakeAddress");
    userElement->LinkEndChild(tempElement);
    tempContent = new TiXmlText("your IP address");
    tempElement->LinkEndChild(tempContent);

    TiXmlElement *configElement = new TiXmlElement("config");
    RootElement->LinkEndChild(configElement);

    tempElement = new TiXmlElement("autologin");
    configElement->LinkEndChild(tempElement);
    tempContent = new TiXmlText("false");
    tempElement->LinkEndChild(tempContent);

    tempElement = new TiXmlElement("authenticationMode");
    configElement->LinkEndChild(tempElement);
    tempContent = new TiXmlText("0");
    tempElement->LinkEndChild(tempContent);

    tempElement = new TiXmlElement("nic");
    configElement->LinkEndChild(tempElement);
    tempContent = new TiXmlText("eth0");
    tempElement->LinkEndChild(tempContent);

    tempElement = new TiXmlElement("echoInterval");
    configElement->LinkEndChild(tempElement);
    tempContent = new TiXmlText("4");
    tempElement->LinkEndChild(tempContent);

    tempElement = new TiXmlElement("intelligentReconnect");
    configElement->LinkEndChild(tempElement);
    tempContent = new TiXmlText("0");
    tempElement->LinkEndChild(tempContent);

    myDocument->SaveFile(filename);
    cout<<"初始化配置文件到"<<filename<<endl;
}
int Mystar::save_file()
{
    TiXmlDocument mystarconf(filename);
    if(mystarconf.LoadFile())
    {

        TiXmlElement* mystarroot = mystarconf.RootElement();
        if(mystarroot == NULL)
            return 1;
        TiXmlElement* UsersElement = mystarroot->FirstChildElement();
        if(UsersElement==NULL)
            return 1;
        TiXmlElement* UserElement = UsersElement->FirstChildElement();
        if(UserElement==NULL)
            return 1;
        TiXmlElement *nickname = UserElement->FirstChildElement();
        TiXmlElement *username = nickname->NextSiblingElement();
        TiXmlElement *password = username->NextSiblingElement();
        TiXmlElement *fakeAddress = password->NextSiblingElement();

        TiXmlText *tempContent = new TiXmlText(user.get_nickname());
        nickname->ReplaceChild(nickname->FirstChild(), *tempContent);

        tempContent = new TiXmlText(user.get_username());
        username->ReplaceChild(username->FirstChild(), *tempContent);

        tempContent = new TiXmlText(user.get_password());
        password->ReplaceChild(password->FirstChild(), *tempContent);

        tempContent = new TiXmlText(user.get_fakeAddress());
        fakeAddress->ReplaceChild(fakeAddress->FirstChild(), *tempContent);

        TiXmlElement *config = UsersElement->NextSiblingElement();
        TiXmlElement *autologinElement = config->FirstChildElement();

        if(autologin)
            tempContent = new TiXmlText("true");
        else
            tempContent = new TiXmlText("false");
        autologinElement->ReplaceChild(autologinElement->FirstChild(), *tempContent);

        cout<<"save to "<<filename<<endl;
        mystarconf.SaveFile();
        return 0;
    }
}
sendpacket.cc:
/**************************************************
 *  sendpacket.cc
 *
 *  Copyright (C) 2009  csip(amoblin@gmail.com)
 *
 *  ChangeLog:
 *
 *  Description:
 *	Warning: this file should be in UTF-8.
 *  
 **************************************************/
#include "Mystar.h"
int Mystar::SendFindServerPacket (libnet_t * l)
{
    /* 发起认证   EAPOL-Start
     * 0x00-0x05    目的MAC  6
     * 0x06-0x0b    源MAC    6
     * 0x0c-0x0d    协议类型 2   888E 代表802.1x
     * 0x0e         协议版本号   1
     * 0x0f         帧类型       1   EAPOL-Start的为01
     * 0x10-0x11    Packet Body Length   2  EAPOL-Start为0000
     * */
    static uint8_t broadPackage[0x3E8] =    //广播包，用于寻找服务器  MAC帧
    {	
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x8E, 0x01, 0x01,
/*目的mac                          源mac                               802.1x      版本 类型*/
0x00,0x00, 0xFF, 0xFF, 0x37, 0x77, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/*包长度   包数据....                                                                       */
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x15, 0x00, 0x00, 0x13, 0x11, 0x38, 0x30, 0x32,
0x31,0x78, 0x2E, 0x65, 0x78, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/*                                                                     锐捷版本号           */
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x1F, 0x00,
0x00,0x00, 0x00, 0x00, 0x13, 0x11, 0x00, 0x28, 0x1A, 0x28, 0x00, 0x00, 0x13, 0x11, 0x17, 0x22,
0x92,0x68, 0x64, 0x66, 0x92, 0x94, 0x62, 0x66, 0x91, 0x93, 0x95, 0x62, 0x93, 0x93, 0x91, 0x94,
0x64,0x61, 0x64, 0x64, 0x65, 0x66, 0x68, 0x94, 0x98, 0xA7, 0x61, 0x67, 0x65, 0x67, 0x9C, 0x6B
/*                                                                      校验码              */
    };

    uint8_t StandardAddr[] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x03 };//802.1标准组播地址

    uint8_t StarAddr[] = { 0x01, 0xD0, 0xF8, 0x00, 0x00, 0x03 };//私有组播地址
    //extern uint8_t m_localMAC[6];
    //extern int m_authenticationMode;
    /*作为参数传入*/
    printf("hello\n");
    if (authenticationMode == 1)    //实达
        memcpy(broadPackage, StarAddr, 6);
    else        //标准
        memcpy(broadPackage, StandardAddr, 6);
    memcpy (broadPackage + 6, localMAC, 6);	//填充MAC地址
    FillNetParamater(&broadPackage[0x17]);
    fputs (">> Searching for server...\n", stdout);
    return (libnet_write_link(l, broadPackage, 0x3E8) == 0x3E8) ? 0 : -1;
}
int Mystar::SendNamePacket (libnet_t * l, const u_char * pkt_data)
{
    /*
     * 发送用户名 EAP-Response/Identity
     * 0x00-0x05    目的MAC             6
     * 0x06-0x0b    源MAC               6
     * 0x0c-0x0d    协议类型            2   888E 代表802.1x
     * 0x0e         协议版本号          1
     * 0x0f         帧类型              1   EAP-Response/Identity的为00
     * 0x10-0x11    Packet Body Length  2   从0x12开始到用户名最后一个字符的长度，网络字节序
     * 0x12                             1   02代表Response 
     * 0x13         Identity            1   填入服务器包中0x13的值  link1
     * 0x14-0x15    重复0x10-0x11       2
     * 0x16         发送用户名          1
     * 0x17开始     用户名              x   
     * 附加包
     * */
    static uint8_t ackPackage[0x3E8] =	//应答包，包括用户名和MD5
    {
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x8E, 0x01, 0x00,
/*目的mac                          源mac                               802.1x协议  版本 类型*/
0x00,0x0D, 0x02, 0x01, 0x00, 0x0D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
/*长度---  2代表应答   长度------  用户                                        */
0xFF,0x37, 0x77, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x11, 0x38, 0x30, 0x32, 0x31, 0x78, 0x2E,
0x65,0x78, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    uint8_t ackShida[] =	//实达专有响应附加包
    {
0xFF,0xFF, 0x37, 0x77, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00,0x00, 0x00, 0x00, 0x00, 0x08, 0x15, 0x00, 0x00, 0x13, 0x11, 0x38, 0x30, 0x32, 0x31, 0x78,
0x2E,0x65, 0x78, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x1F, 0x00, 0x00, 0x00,
0x00,0x00, 0x13, 0x11, 0x00, 0x28, 0x1A, 0x28, 0x00, 0x00, 0x13, 0x11, 0x17, 0x22, 0x92, 0x68,
0x64,0x66, 0x92, 0x94, 0x62, 0x66, 0x91, 0x93, 0x95, 0x62, 0x93, 0x93, 0x91, 0x94, 0x64, 0x61,
0x64,0x64, 0x65, 0x66, 0x68, 0x94, 0x98, 0xA7, 0x61, 0x67, 0x65, 0x67, 0x9C, 0x6B
    };

    memcpy (ackPackage, destMAC, 6);	//将目的MAC地址填入组织回复的包
    memcpy (ackPackage + 6, localMAC, 6);	//将本机MAC地址填入组织回复的包

    ackPackage[0x12] = 0x02;	//code,2代表应答
    ackPackage[0x13] = pkt_data[0x13];	//id, HERE as if it's alway 1 from ShiDa ??

    int nameLen;
    nameLen = strlen (user.get_username());

    *(short *) (ackPackage + 0x10) = htons ((short) (5 + nameLen));	//len
    *(short *) (ackPackage + 0x14) = *(short *) (ackPackage + 0x10);	//len
    memcpy (ackPackage + 0x17, user.get_username(), nameLen);	//填入用户名

    FillNetParamater (&ackShida[0x05]);
    memcpy (ackPackage + 0x17 + nameLen, ackShida, 0x6e);//实达附加包

    fputs (">> Sending user name...\n", stdout);

    return (libnet_write_link (l, ackPackage, 0x3E8) == 0x3E8) ? 0 : -1;
}
int Mystar::SendPasswordPacket (libnet_t * l, const u_char * pkt_data)
{
    /*
     * 发送密码   EAP-Response
     * 0x00-0x05    目的MAC             6
     * 0x06-0x0b    源MAC               6
     * 0x0c-0x0d    协议类型            2   888E 代表802.1x
     * 0x0e         协议版本号          1
     * 0x0f         帧类型              1   EAP-Response的为00
     * 0x10-0x11    Packet Body Length  2   从0x12开始到用户名最后一个字符的长度，网络字节序
     * 0x12                             1   02代表Response 
     * 0x13         Identity            1   服务器包中0x13的值
     * 0x14-0x15    重复0x10-0x11       2
     * 0x16         发送用户名和密码    1
     * 0x18-0x27    加密密码            16
     * 0x28开始     用户名              x  
     * 附加包
     * */
    static uint8_t ackPackage[0x3E8] =	//应答包，包括用户名和MD5
    {
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x8E, 0x01, 0x00,
/*目的mac                          源mac                               */
0x00,0x0D, 0x02, 0x01, 0x00, 0x0D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
/*         2代表应答                           密码******************************************/
0xFF,0x37, 0x77, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/********************************************  用户名                      */
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x11, 0x38, 0x30, 0x32, 0x31, 0x78, 0x2E,
0x65,0x78, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    uint8_t ackShida[] =	//实达专有响应附加包
    {
0xFF,0xFF, 0x37, 0x77, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00,0x00, 0x00, 0x00, 0x00, 0x08, 0x15, 0x00, 0x00, 0x13, 0x11, 0x38, 0x30, 0x32, 0x31, 0x78,
0x2E,0x65, 0x78, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x1F, 0x00, 0x00, 0x00,
0x00,0x00, 0x13, 0x11, 0x00, 0x28, 0x1A, 0x28, 0x00, 0x00, 0x13, 0x11, 0x17, 0x22, 0x92, 0x68,
0x64,0x66, 0x92, 0x94, 0x62, 0x66, 0x91, 0x93, 0x95, 0x62, 0x93, 0x93, 0x91, 0x94, 0x64, 0x61,
0x64,0x64, 0x65, 0x66, 0x68, 0x94, 0x98, 0xA7, 0x61, 0x67, 0x65, 0x67, 0x9C, 0x6B
    };

    md5.md5Len=0;

    int nameLen, passwordLen;

    nameLen = strlen (user.get_username());
    passwordLen = strlen (user.get_password());

    memcpy (ackPackage, destMAC, 6);
    memcpy (ackPackage + 6, localMAC, 6);	//将本机MAC地址填入组织回复的包

    ackPackage[0x12] = 0x02;	//code,2代表应答
    ackPackage[0x13] = pkt_data[0x13];	//id
    *(ackPackage + 0x16) = *(pkt_data + 0x16);	//type，即应答方式,HERE should alway be 4

    *(short *) (ackPackage + 0x10) = htons ((short) (22 + nameLen));	//len
    *(short *) (ackPackage + 0x14) = *(short *) (ackPackage + 0x10);

    md5.md5Data[md5.md5Len++] = ackPackage[0x13];	//ID
    memcpy (md5.md5Data + md5.md5Len, user.get_password(), passwordLen);
    md5.md5Len += passwordLen;	//密码
    memcpy (md5.md5Data + md5.md5Len, pkt_data + 0x18, pkt_data[0x17]);
    md5.md5Len += pkt_data[0x17];	//密匙
    md5.md5Dig = md5.ComputeHash(md5.md5Data, md5.md5Len);

    ackPackage[0x17] = 16;	//length of md5sum is always 16.
    memcpy (ackPackage + 0x18, md5.md5Dig, 16);

    memcpy (ackPackage + 0x28, user.get_username(), nameLen);

    FillNetParamater (&ackShida[0x05]);
    memcpy (ackPackage + 0x28 + nameLen, ackShida, 0x6e);//实达附加包

    fputs (">> Sending password... \n", stdout);
    return (libnet_write_link (l, ackPackage, 0x3E8) == 0x3E8) ? 0 : -1;
}
int Mystar::SendEchoPacket(libnet_t * l, const u_char * pkt_data, ULONG_BYTEARRAY *m_serialNo)
{
    /*  发送激活包
     * 0x00-0x05    目的MAC             6
     * 0x06-0x0b    源MAC               6
     * 0x0c-0x0d    协议类型            2   888E 代表802.1x
     * 0x0e         协议版本号          1
     * 0x0f         帧类型              1   这里为bf
     * 0x10-0x11    Packet Body Length  2   从0x12开始到用户名最后一个字符的长度，网络字节序
     * 0x12-0x17    ff ff 37 77 7f 9f   6
     * 0x18-0x1b    认证成功时收到的
     * 0x1c-0x1f    ff ff 37 77         4
     * 0x22-0x25    序列号转化
     * 0x26-0x2c    ff ff 37 77 7f 3f ff    7
     * */
    static uint8_t echoPackage[] =	//echo包，用于每5秒钟激活一次
    {
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x8E, 0x01, 0xBF,
/*目的mac                          源mac                               其他*/
0x00,0x1E, 0xFF, 0xFF, 0x37, 0x77, 0x7F, 0x9F, 0xF7, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x37, 0x77,
/*                                             alog0 alog1 alog2 alog3     */
0x7F,0x9F, 0xF7, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x37, 0x77, 0x7F, 0x3F, 0xFF
/*         alog0 */
    };
    ULONG_BYTEARRAY uCrypt1, uCrypt2, uCrypt1_After, uCrypt2_After;

    m_serialNo->ulValue++;

    uCrypt1.ulValue = m_key.ulValue + m_serialNo->ulValue;
    uCrypt2.ulValue = m_serialNo->ulValue;

    memcpy (echoPackage, destMAC, 6);
    memcpy (echoPackage + 6, localMAC, 6);

    uCrypt1_After.ulValue = htonl (uCrypt1.ulValue);
    uCrypt2_After.ulValue = htonl (uCrypt2.ulValue);

    echoPackage[0x18] = Alog (uCrypt1_After.btValue[0]);
    echoPackage[0x19] = Alog (uCrypt1_After.btValue[1]);
    echoPackage[0x1a] = Alog (uCrypt1_After.btValue[2]);
    echoPackage[0x1b] = Alog (uCrypt1_After.btValue[3]);
    echoPackage[0x22] = Alog (uCrypt2_After.btValue[0]);
    echoPackage[0x23] = Alog (uCrypt2_After.btValue[1]);
    echoPackage[0x24] = Alog (uCrypt2_After.btValue[2]);
    echoPackage[0x25] = Alog (uCrypt2_After.btValue[3]);
#ifdef DEBUG
    //printf("send a echo.\n");
#endif
    return (libnet_write_link(l, echoPackage, 0x2d) == 0x2d) ? 0 : -1;
    //TODO:0x2d的含义？
}
int Mystar::SendEndCertPacket (libnet_t * l)//结束通信
{
    /* 断开连接 EAP-Logoff
     * 0x00-0x05    目的MAC             6
     * 0x06-0x0b    源MAC               6
     * 0x0c-0x0d    协议类型            2   888E 代表802.1x
     * 0x0e         协议版本号          1
     * 0x0f         帧类型              1   EAP-Logoff的为02
     * 0x10-0x11    Packet Body Length  2   EAP-Logoff为0000
     * */
    static uint8_t ExitPacket[] =
    {
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x8E, 0x01, 0x02,
/*目的mac                          源mac                               802.1x               */
0x00,0x00, 0xFF, 0xFF, 0x37, 0x77, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x15, 0x00, 0x00, 0x13, 0x11, 0x38, 0x30, 0x32,
0x31,0x78, 0x2E, 0x65, 0x78, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x1F, 0x00,
0x00,0x01, 0x00, 0x00, 0x13, 0x11, 0x00, 0x28, 0x1A, 0x28, 0x00, 0x00, 0x13, 0x11, 0x17, 0x22,
0x64,0x91, 0x60, 0x60, 0x65, 0x65, 0x69, 0x61, 0x64, 0x64, 0x94, 0x93, 0x91, 0x92, 0x96, 0x65,
0x95,0x64, 0x68, 0x91, 0x62, 0x68, 0x62, 0x94, 0x9A, 0xD6, 0x94, 0x68, 0x66, 0x69, 0x6C, 0x65
    };

    memcpy(ExitPacket, destMAC, 6);
    memcpy(ExitPacket + 6, localMAC, 6);
    FillNetParamater (&ExitPacket[0x17]);
    cout<<">> Logouting... \n"<<endl;
    return (libnet_write_link (l, ExitPacket, 0x80) == 0x80) ? 0 : -1;
}
blog.cc:
/***************************************************
 *  blog.cc
 *
 *  Copyright (C) 2009  csip(amoblin@gmail.com)
 *
 *  ChangeLog:
 *
 *  Description:
 *	Warning: this file should be in UTF-8.
 *  
 ****************************************************/
#include "Mystar.h"

static int blogIsInitialized = 0;
static unsigned char m_IP[4];
static unsigned char m_NetMask[4];
static unsigned char m_NetGate[4];
static unsigned char m_DNS1[4];
static unsigned char circleCheck[2];	//那两个鬼值

//configure the 4 parameters Blog() and FillNetParameter() need.
void Mystar::InitializeBlog (const unsigned char *m_ip, const unsigned char *m_netmask,
        const unsigned char *m_netgate, const unsigned char *m_dns1)
{
  memcpy (m_IP, m_ip, 4);
  memcpy (m_NetMask, m_netmask, 4);
  memcpy (m_NetGate, m_netgate, 4);
  memcpy (m_DNS1, m_dns1, 4);

  Blog ();

  blogIsInitialized = 1;
}
//Fill in some additional information  Ruijie Corp. required.
//You should call InitializeBlog() before calling this function.
void Mystar::FillNetParamater (unsigned char ForFill[])
{
  if (blogIsInitialized == 0)
    err_quit ("Blog algorithm not initialied yet \n");

  ForFill[0] = Alog (m_IP[0]);
  ForFill[1] = Alog (m_IP[1]);
  ForFill[2] = Alog (m_IP[2]);
  ForFill[3] = Alog (m_IP[3]);
  ForFill[4] = Alog (m_NetMask[0]);
  ForFill[5] = Alog (m_NetMask[1]);
  ForFill[6] = Alog (m_NetMask[2]);
  ForFill[7] = Alog (m_NetMask[3]);
  ForFill[8] = Alog (m_NetGate[0]);
  ForFill[9] = Alog (m_NetGate[1]);
  ForFill[10] = Alog (m_NetGate[2]);
  ForFill[11] = Alog (m_NetGate[3]);
  ForFill[12] = Alog (m_DNS1[0]);
  ForFill[13] = Alog (m_DNS1[1]);
  ForFill[14] = Alog (m_DNS1[2]);
  ForFill[15] = Alog (m_DNS1[3]);
  ForFill[16] = Alog (circleCheck[0]);
  ForFill[17] = Alog (circleCheck[1]);
}
//A transformation of one-byte-for-one-byte
unsigned char Mystar::Alog (unsigned char BForAlog)
{
  int a = 0, b = 0, c = 0, d = 0, iRt;

  a = BForAlog;
  c = a;
  d = a;
  c &= 0x40;
  b = a;
  d >>= 2;
  c |= d;
  d = a;
  c >>= 2;
  d &= 0x20;
  c |= d;
  d = a;
  c >>= 2;
  d &= 0x10;
  c |= d;

  d = a;
  d &= 2;
  b <<= 2;
  d |= b;
  b = a;
  d <<= 2;
  b &= 4;
  a &= 8;
  d |= b;
  d <<= 2;
  d |= a;

  c >>= 1;
  d <<= 1;
  c |= d;
  iRt = (~c) & 0xff;
  return iRt;
}
//那帮家伙们，单靠这个算法就想区别实达客户端和非实达客户端 -_- !! 
//The only use of function Blog() is to work out circleCheck[2],
//with and only with the help of 4 parameters----m_IP, m_NetMask, m_NetGate, m_DNS1
void Mystar::Blog (void)
{
  static unsigned char Table[] = 
  {
0x00,0x00, 0x21, 0x10, 0x42, 0x20, 0x63, 0x30, 0x84, 0x40, 0xA5, 0x50, 0xC6, 0x60, 0xE7, 0x70,
0x08,0x81, 0x29, 0x91, 0x4A, 0xA1, 0x6B, 0xB1, 0x8C, 0xC1, 0xAD, 0xD1, 0xCE, 0xE1, 0xEF, 0xF1,
0x31,0x12, 0x10, 0x02, 0x73, 0x32, 0x52, 0x22, 0xB5, 0x52, 0x94, 0x42, 0xF7, 0x72, 0xD6, 0x62,
0x39,0x93, 0x18, 0x83, 0x7B, 0xB3, 0x5A, 0xA3, 0xBD, 0xD3, 0x9C, 0xC3, 0xFF, 0xF3, 0xDE, 0xE3,
0x62,0x24, 0x43, 0x34, 0x20, 0x04, 0x01, 0x14, 0xE6, 0x64, 0xC7, 0x74, 0xA4, 0x44, 0x85, 0x54,
0x6A,0xA5, 0x4B, 0xB5, 0x28, 0x85, 0x09, 0x95, 0xEE, 0xE5, 0xCF, 0xF5, 0xAC, 0xC5, 0x8D, 0xD5,
0x53,0x36, 0x72, 0x26, 0x11, 0x16, 0x30, 0x06, 0xD7, 0x76, 0xF6, 0x66, 0x95, 0x56, 0xB4, 0x46,
0x5B,0xB7, 0x7A, 0xA7, 0x19, 0x97, 0x38, 0x87, 0xDF, 0xF7, 0xFE, 0xE7, 0x9D, 0xD7, 0xBC, 0xC7,
0xC4,0x48, 0xE5, 0x58, 0x86, 0x68, 0xA7, 0x78, 0x40, 0x08, 0x61, 0x18, 0x02, 0x28, 0x23, 0x38,
0xCC,0xC9, 0xED, 0xD9, 0x8E, 0xE9, 0xAF, 0xF9, 0x48, 0x89, 0x69, 0x99, 0x0A, 0xA9, 0x2B, 0xB9,
0xF5,0x5A, 0xD4, 0x4A, 0xB7, 0x7A, 0x96, 0x6A, 0x71, 0x1A, 0x50, 0x0A, 0x33, 0x3A, 0x12, 0x2A,
0xFD,0xDB, 0xDC, 0xCB, 0xBF, 0xFB, 0x9E, 0xEB, 0x79, 0x9B, 0x58, 0x8B, 0x3B, 0xBB, 0x1A, 0xAB,
0xA6,0x6C, 0x87, 0x7C, 0xE4, 0x4C, 0xC5, 0x5C, 0x22, 0x2C, 0x03, 0x3C, 0x60, 0x0C, 0x41, 0x1C,
0xAE,0xED, 0x8F, 0xFD, 0xEC, 0xCD, 0xCD, 0xDD, 0x2A, 0xAD, 0x0B, 0xBD, 0x68, 0x8D, 0x49, 0x9D,
0x97,0x7E, 0xB6, 0x6E, 0xD5, 0x5E, 0xF4, 0x4E, 0x13, 0x3E, 0x32, 0x2E, 0x51, 0x1E, 0x70, 0x0E,
0x9F,0xFF, 0xBE, 0xEF, 0xDD, 0xDF, 0xFC, 0xCF, 0x1B, 0xBF, 0x3A, 0xAF, 0x59, 0x9F, 0x78, 0x8F,
0x88,0x91, 0xA9, 0x81, 0xCA, 0xB1, 0xEB, 0xA1, 0x0C, 0xD1, 0x2D, 0xC1, 0x4E, 0xF1, 0x6F, 0xE1,
0x80,0x10, 0xA1, 0x00, 0xC2, 0x30, 0xE3, 0x20, 0x04, 0x50, 0x25, 0x40, 0x46, 0x70, 0x67, 0x60,
0xB9,0x83, 0x98, 0x93, 0xFB, 0xA3, 0xDA, 0xB3, 0x3D, 0xC3, 0x1C, 0xD3, 0x7F, 0xE3, 0x5E, 0xF3,
0xB1,0x02, 0x90, 0x12, 0xF3, 0x22, 0xD2, 0x32, 0x35, 0x42, 0x14, 0x52, 0x77, 0x62, 0x56, 0x72,
0xEA,0xB5, 0xCB, 0xA5, 0xA8, 0x95, 0x89, 0x85, 0x6E, 0xF5, 0x4F, 0xE5, 0x2C, 0xD5, 0x0D, 0xC5,
0xE2,0x34, 0xC3, 0x24, 0xA0, 0x14, 0x81, 0x04, 0x66, 0x74, 0x47, 0x64, 0x24, 0x54, 0x05, 0x44,
0xDB,0xA7, 0xFA, 0xB7, 0x99, 0x87, 0xB8, 0x97, 0x5F, 0xE7, 0x7E, 0xF7, 0x1D, 0xC7, 0x3C, 0xD7,
0xD3,0x26, 0xF2, 0x36, 0x91, 0x06, 0xB0, 0x16, 0x57, 0x66, 0x76, 0x76, 0x15, 0x46, 0x34, 0x56,
0x4C,0xD9, 0x6D, 0xC9, 0x0E, 0xF9, 0x2F, 0xE9, 0xC8, 0x99, 0xE9, 0x89, 0x8A, 0xB9, 0xAB, 0xA9,
0x44,0x58, 0x65, 0x48, 0x06, 0x78, 0x27, 0x68, 0xC0, 0x18, 0xE1, 0x08, 0x82, 0x38, 0xA3, 0x28,
0x7D,0xCB, 0x5C, 0xDB, 0x3F, 0xEB, 0x1E, 0xFB, 0xF9, 0x8B, 0xD8, 0x9B, 0xBB, 0xAB, 0x9A, 0xBB,
0x75,0x4A, 0x54, 0x5A, 0x37, 0x6A, 0x16, 0x7A, 0xF1, 0x0A, 0xD0, 0x1A, 0xB3, 0x2A, 0x92, 0x3A,
0x2E,0xFD, 0x0F, 0xED, 0x6C, 0xDD, 0x4D, 0xCD, 0xAA, 0xBD, 0x8B, 0xAD, 0xE8, 0x9D, 0xC9, 0x8D,
0x26,0x7C, 0x07, 0x6C, 0x64, 0x5C, 0x45, 0x4C, 0xA2, 0x3C, 0x83, 0x2C, 0xE0, 0x1C, 0xC1, 0x0C,
0x1F,0xEF, 0x3E, 0xFF, 0x5D, 0xCF, 0x7C, 0xDF, 0x9B, 0xAF, 0xBA, 0xBF, 0xD9, 0x8F, 0xF8, 0x9F,
0x17,0x6E, 0x36, 0x7E, 0x55, 0x4E, 0x74, 0x5E, 0x93, 0x2E, 0xB2, 0x3E, 0xD1, 0x0E, 0xF0, 0x1E
};
  static unsigned char sCircleBase[0x15] = 
  {
0x00,0x00, 0x13, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00,0x00, 0x00, 0x00, 0x00
  };
  int iCircle = 0x15;
  int i, ax = 0, bx = 0, dx = 0;

  sCircleBase[0x05] = m_IP[0];
  sCircleBase[0x06] = m_IP[1];
  sCircleBase[0x07] = m_IP[2];
  sCircleBase[0x08] = m_IP[3];
  sCircleBase[0x09] = m_NetMask[0];
  sCircleBase[0x0a] = m_NetMask[1];
  sCircleBase[0x0b] = m_NetMask[2];
  sCircleBase[0x0c] = m_NetMask[3];
  sCircleBase[0x0d] = m_NetGate[0];
  sCircleBase[0x0e] = m_NetGate[1];
  sCircleBase[0x0f] = m_NetGate[2];
  sCircleBase[0x10] = m_NetGate[3];
  sCircleBase[0x11] = m_DNS1[0];
  sCircleBase[0x12] = m_DNS1[1];
  sCircleBase[0x13] = m_DNS1[2];
  sCircleBase[0x14] = m_DNS1[3];

  for (i = 0; i < iCircle; i++)
    {
      dx = ax;
      bx = 0;
      bx = (bx & 0xff00) | sCircleBase[i];	// add "( )" by cdx
      dx &= 0xffff;
      dx >>= 8;
      dx ^= bx;
      bx = 0;
      bx &= 0x00ff;
      bx |= (ax & 0xff) << 8;

      ax = Table[dx * 2] | Table[dx * 2 + 1] << 8;
      ax ^= bx;
    }
  circleCheck[0] = (unsigned char) ((ax & 0xff00) >> 8);
  circleCheck[1] = (unsigned char) (ax & 0x00ff);
}
gbk2utf8.cc:
/************************************************
 *  gbk2utf8.cc
 *
 *  Copyright (C) 2009  csip(amoblin@gmail.com)
 *
 *  ChangeLog:
 *
 *  Description:
 *	Warning: this file should be in UTF-8.
 *  
 *************************************************/
#include "Mystar.h"
#include <iconv.h>
/*
 * 这个未能实现，不知道为什么？
char *gbk2utf8(char *src)
{
    //printf("the previous string is:%s\n",src);
    iconv_t conv = iconv_open("utf-8","GB2312");
    if(conv == (iconv_t)-1)
    {
        printf("iconv_open:%d\n",errno);
    }

    size_t msgBuf_len = strlen(src);//不包含\0的长度
    //size_t *msgBuf_len_size_t = &msgBuf_len;
    size_t msgBuf_utf8_len = msgBuf_len * 2;
    //size_t *msgBuf_utf8_len_size_t = &msgBuf_utf8_len;
    char *msgBuf_utf8 = (char*)malloc(msgBuf_utf8_len);
    bzero(msgBuf_utf8,msgBuf_utf8_len);
    int ret=0;
    ret = iconv(conv, (char**)&src, &msgBuf_len, &msgBuf_utf8, &msgBuf_utf8_len);
    if(ret == -1)
    {
        printf("iconv:%d\n",errno);
    }
    else
    {
        printf("conv success!\n");
        //printf("now the string is:%s\n",msgBuf_utf8);
        return msgBuf_utf8;
    }
    iconv_close(conv);

}
*/

//代码转换:从一种编码转为另一种编码
int code_convert(char *from_charset,char *to_charset,char *inbuf,size_t inlen,char *outbuf,size_t outlen)
{
    iconv_t cd;
    int rc;
    char **pin = &inbuf;
    char **pout = &outbuf;

    cd = iconv_open(to_charset,from_charset);
    if (cd==0) return -1;
    memset(outbuf,0,outlen);
    if (iconv(cd,pin,&inlen,pout,&outlen)==-1) return -1;
    iconv_close(cd);
    return 0;
}
//UNICODE码转为GB2312码
int u2g(char *inbuf,int inlen,char *outbuf,int outlen)
{
    //char* to string
    char from_charset[] = "utf-8";
    char to_charset[] = "gb2312";
    return code_convert(from_charset,to_charset,inbuf,inlen,outbuf,outlen);
}
//GB2312码转为UNICODE码
int g2u(char *inbuf,size_t inlen,char *outbuf,size_t outlen)
{
    //char* to string
    char from_charset[] = "gb2312";
    char to_charset[] = "utf-8";
    return code_convert(from_charset,to_charset,inbuf,inlen,outbuf,outlen);
}
char *Mystar::gbk2utf8(char *src)//将gbk转化为utf8编码 2009-03-25 00:58成功!
{
    char utf8_str[255];
    int rc = g2u(src,strlen(src),utf8_str,255);
    char *utf8_p = utf8_str;
    return utf8_p;
}

/*
 * 另一种比较底层的编码转换算法,未用iconv,不会用,要求对编码字节很了解
 void Mystar::ConvertGBKToUtf8(CString &amp,CString strGBK)
 { 
 int len=MultiByteToWideChar(CP_ACP, 0, (LPCTSTR)strGBK, -1, NULL,0); 
 unsigned short * wszUtf8 = new unsigned short[len+1]; 
 memset(wszUtf8, 0, len * 2 + 2); 
 MultiByteToWideChar(CP_ACP, 0, (LPCTSTR)strGBK, -1, (LPWSTR)wszUtf8, len); 
 len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)wszUtf8, -1, NULL, 0, NULL, NULL); 
 char *szUtf8=new char[len + 1]; 
 memset(szUtf8, 0, len + 1); 
 WideCharToMultiByte (CP_UTF8, 0, (LPCWSTR)wszUtf8, -1, szUtf8, len, NULL,NULL); 
 //strGBK = szUtf8; 
 amp=szUtf8;
 delete[] szUtf8; 
 delete[] wszUtf8; 
 } 

 void ConvertUtf8ToGBK(CString &amp,CString strUtf8)
 { 
 int len=MultiByteToWideChar(CP_UTF8, 0, (LPCTSTR)strUtf8, -1, NULL,0); 
 unsigned short * wszGBK = new unsigned short[len+1]; 
 memset(wszGBK, 0, len * 2 + 2); 
 MultiByteToWideChar(CP_UTF8, 0, (LPCTSTR)strUtf8, -1, (LPWSTR)wszGBK, len); 
 len = WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)wszGBK, -1, NULL, 0, NULL, NULL); 
 char *szGBK=new char[len + 1]; 
 memset(szGBK, 0, len + 1); 
 WideCharToMultiByte (CP_ACP, 0, (LPCWSTR)wszGBK, -1, szGBK, len, NULL,NULL); 
//strUtf8 = szGBK; 
amp=szGBK;
delete[] szGBK; 
delete[] wszGBK; 
}
 */
myerr.cc:
/*****************************************************
 *  myerr.cc
 *
 *  Copyright (C) 2009  csip(amoblin@gmail.com)
 *
 *  ChangeLog:
 *
 *  Description:
 *	Warning: this file should be in UTF-8.
 *  
 ******************************************************/

/* This file comes from APUE, slightly edited by NetXRay@byhh */

#include "Mystar.h"
/* Nonfatal error related to a system call.
 * Print a message and return. */
void Mystar::err_ret(const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	err_doit(1, fmt, ap);
	va_end(ap);
	return;
}
/* Fatal error related to a system call.
 * Print a message and terminate. */
void Mystar::err_sys(const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	err_doit(1, fmt, ap);
	va_end(ap);
	exit(1);
}
/* Fatal error related to a system call.
 * Print a message, dump core, and terminate. */
void Mystar::err_dump(const char *fmt, ...)
{
	va_list		ap;

	va_start(ap, fmt);
	err_doit(1, fmt, ap);
	va_end(ap);
	abort();		/* dump core and terminate */
	exit(1);		/* shouldn't get here */
}
/* Nonfatal error unrelated to a system call.
 * Print a message and return. */
void Mystar::err_msg(const char *fmt, ...)
{
	va_list		ap;

	va_start(ap, fmt);
	err_doit(0, fmt, ap);
	va_end(ap);
	return;
}
/* Fatal error unrelated to a system call.
 * Print a message and terminate. */
void Mystar::err_quit(const char *fmt, ...)
{
	va_list		ap;

	va_start(ap, fmt);
	err_doit(0, fmt, ap);
	va_end(ap);
	exit(1);
}
/* Print a message and return to caller.
 * Caller specifies "errnoflag". */
void Mystar::err_doit(int errnoflag, const char *fmt, va_list ap)
{
	int		errno_save;
	char	buf[4096];

	errno_save = errno;		/* value caller might want printed */
	vsprintf(buf, fmt, ap);
	if (errnoflag)
		sprintf(buf+strlen(buf), ": %s", strerror(errno_save));
	strcat(buf, "\n");
	fflush(stdout);		/* in case stdout and stderr are the same */
	fputs(buf, stderr);
	fflush(NULL);		/* flushes all stdio output streams */
	return;
}
main.cc:
/***********************************************
 *  main.cc
 *
 *  Copyright (C) 2009  csip(amoblin@gmail.com)
 *
 *  ChangeLog:
 *
 *  Description:
 *	Warning: this file should be in UTF-8.
 *  
 ***********************************************/
#include "gMystar.h"
int main(int argc, char *argv[])
{
    if(argc == 2)
    {
        if(!strcmp(argv[1],"--nogui"))
        {
            Mystar mystar;
        }
        else if(!strcmp(argv[1],"--help"))
        {
            gMystar::help();
        }
        else if(!strcmp(argv[1],"--test"))
        {
        }
        else if(!strcmp(argv[1],"-s"))
        {
        }
        else
        {
            cout<<"usage: gMystar --help for more details"<<endl;
        }
    }
    else
    {
        //gMystar gmystar(argc, argv);
        Gtk::Main kit(argc, argv);
        gMystar gmystar;
        kit.run();
    }
    return 0;
}
Makefile:
###############################
# Makefile
#
# Copyright (C) 2009  csip(amoblin@gmail.com)
#
# ChangeLog:
#
# Description:
# Warning: this file should be in UTF-8.
#
# Target, compiler and objects.
###############################
gMystar_HOME   = ..
OBJ    = $(gMystar_HOME)/obj
DOC    = $(gMystar_HOME)/doc
DIA    = $(gMystar_HOME)/dia
SRC    = $(gMystar_HOME)/src
BIN    = $(gMystar_HOME)/bin
DATA   = $(gMystar_HOME)/data
CC     = g++
EXEC   = $(BIN)/gMystar

# Use for compile.
CFLAGS = `pkg-config --cflags dbus-glib-1 libglademm-2.4 gtkmm-2.4 libnotifymm-1.0 libnm_glib`
# Use for link.
CLIBS  = `pkg-config --libs dbus-glib-1 gtkmm-2.4 libglademm-2.4 libnotifymm-1.0 libnm_glib`
#FLAGS = -DDEBUG -Wall -pedantic -ansi
FLAGS = -DDEBUG 
#xml flag
XMLFLAGS = `pkg-config libxml++-2.6 --cflags --libs`

all:	$(EXEC)

SRCS := MD5.cc checkAndSetConfig.cc User.cc blog.cc sendpacket.cc myerr.cc gbk2utf8.cc Mystar.cc tinyxml/tinyxml.cpp tinyxml/tinystr.cpp tinyxml/tinyxmlerror.cc tinyxml/tinyxmlparser.cpp

OBJS := $(addsuffix .o, $(basename $(SRCS)))

SRCS :=$(addprefix $(SRC)/, $(SRCS))

OBJS := $(addprefix $(OBJ)/, $(OBJS))

$(EXEC): $(OBJS) $(OBJ)/gMystar.o $(OBJ)/main.o
	$(CC) $(CLIBS) -lnet -lpcap $^ -g -o $@

$(OBJ)/gMystar.o : $(SRC)/gMystar.cc 
	$(CC) --static $(FLAGS) $(CFLAGS) -lnotify -c $< -o $@

$(OBJ)/main.o : $(SRC)/main.cc 
	$(CC) $(FLAGS) $(CFLAGS) -c $< -o $@

$(OBJ)/Mystar.o : $(SRC)/Mystar.cc 
	$(CC) $(FLAGS) `pkg-config --cflags dbus-glib-1 libnm_glib` -c $< -o $@

$(OBJ)/%.o : $(SRC)/%.cc
	$(CC) $(FLAGS) `pkg-config --cflags dbus-glib-1 libnm_glib` -c $< -o $@

$(OBJ)/%.o : $(SRC)/%.cpp
	$(CC) $(FLAGS) -c $< -o $@

clean:
	rm -rf $(OBJ)/*.o
run:
	(xterm -e "cd $(BIN);sudo ./gMystar")
runc:
	(xterm -e "cd $(BIN);sudo ./gMystar --nogui")
runt:
	(cd $(BIN);sudo ./gMystar --test)
install:
	#mkdir /usr/share/gMystar
	cp -vr $(BIN) /usr/share/gMystar
	cp -vr $(DATA) /usr/share/gMystar
	#ln -s /usr/share/gMystar/bin/gMysar /usr/sbin/gMystar
	cp -v /usr/share/gMystar/bin/gMystar /usr/sbin/gMystar
debug:
	cd $(BIN);sudo gdb ./gMystar
gMystar_HOME_r   = $(gMystar_HOME)/../gmystar
release:
	tar jcvf ~/Dropbox/Public/gmystar.tar.bz2 $(gMystar_HOME_r)/* --exclude $(gMystar_HOME_r)/doc --exclude $(gMystar_HOME_r)/dia --exclude $(gMystar_HOME_r)/ref
	$(gMystar_HOME)/makeall
	$(gMystar_HOME)/back_windows
makeall:
#!/bin/bash
#===============================================================================
#
#          FILE:  makesource.sh
# 
#         USAGE:  ./makesource.sh 
# 
#   DESCRIPTION:  make all source file into one
# 
#       OPTIONS:  ---
#  REQUIREMENTS:  ---
#          BUGS:  ---
#         NOTES:  ---
#        AUTHOR:  csip (), amoblin@gmail.com
#       COMPANY:  bistu
#       VERSION:  1.0
#       CREATED:  2009年05月24日 15时55分00秒 CST
#      REVISION:  ---
#===============================================================================

dest=../doc/程序源代码清单.doc
cd src
echo "/**************************source file list*******************************/" > $dest
echo "gMystar.h:">>$dest
cat gMystar.h >> $dest
echo "gMystar.cc:">>$dest
cat gMystar.cc >> $dest
echo "Mystar.h:">>$dest
cat Mystar.h >> $dest
echo "Mystar.cc:">>$dest
cat Mystar.cc >>$dest
echo "User.h:">>$dest
cat User.h >>$dest
echo "User.cc:">>$dest
cat User.cc >>$dest
echo "MD5.h:">>$dest
cat MD5.h >>$dest
echo "MD5.cc:">>$dest
cat MD5.cc >>$dest
echo "checkAndSetConfig.cc:">>$dest
cat checkAndSetConfig.cc >>$dest
echo "sendpacket.cc:">>$dest
cat sendpacket.cc >>$dest
echo "blog.cc:">>$dest
cat blog.cc >>$dest
echo "gbk2utf8.cc:">>$dest
cat gbk2utf8.cc >>$dest
echo "myerr.cc:">>$dest
cat myerr.cc >>$dest
echo "main.cc:">>$dest
cat main.cc >>$dest
echo "Makefile:">>$dest
cat Makefile >>$dest
echo "makeall:">>$dest
cat ../makeall >>$dest
echo "back_windows">>$dest
cat ../back_windows>>$dest
echo "doc2pdf">>$dest
cat ../doc2pdf>>$dest
echo "ChangeLog:">>$dest
cat ../ChangeLog >> $dest
back_windows
#!/bin/bash
#===============================================================================
#
#          FILE:  back_windows.sh
# 
#         USAGE:  ./back_windows.sh 
# 
#   DESCRIPTION:  make a backup for windows environment
# 
#       OPTIONS:  ---
#  REQUIREMENTS:  ---
#          BUGS:  ---
#         NOTES:  ---
#        AUTHOR:  amoblin 崔 (), amoblin@gmail.com
#       COMPANY:  bistu
#       VERSION:  1.0
#       CREATED:  2009年04月20日 22时49分39秒 CST
#      REVISION:  ---
#===============================================================================

cp -r ../gmystar ~/Dropbox/Public/
cd ~/Dropbox/Public/gmystar

find . -exec file {} \;|grep text|grep -v CRLF|awk -F ":" '{print $1}'>filelist
while read line; do
    unix2dos "$line"
done < filelist
doc2pdf
#!/bin/bash
#===============================================================================
#
#          FILE:  doc2pdf.sh
# 
#         USAGE:  ./doc2pdf.sh 
# 
#   DESCRIPTION:  conver document in "doc" folder to "pdf" folder
# 
#       OPTIONS:  ---
#  REQUIREMENTS:  ---
#          BUGS:  ---
#         NOTES:  ---
#        AUTHOR:  csip (), amoblin@gmail.com
#       COMPANY:  bistu
#       VERSION:  1.0
#       CREATED:  2009年05月24日 16时57分08秒 CST
#      REVISION:  ---
#===============================================================================

cd doc
unoconv -f pdf *.*
mv *.pdf ../doc_pdf
ChangeLog:
2009年05月24日 星期日 15时40分12秒
	修改论文，明确结构;
	增加src中各文件的说明注释，便于程序源代码的打印。
	去掉back_window.sh的后缀
	增加makeall脚本，将源文件统一于一个文件，以生成程序源代码清单
	修改pdf文件夹为doc_pdf，增加doc2pdf脚本
	增加dia的TODO
	确定翻译文章：lordan or eap white paper?
2009年05月13日 星期三 19时12分55秒
	完成论文封面。
2009年04月22日 星期三 01时22分53秒
	整理文档，有几个问题：
	1。MAC帧，802.1x协议，EAP协议，RADIUS协议，它们之间什么关系？
	2.帧的研究
2009年04月21日 星期二 12时57分37秒
	用libnm_glib实现了检测网口状态。
	14:23 实现了自动重连！
2009年04月20日 星期一 21时55分20秒
	完成notify功能。用libnotify-1.0
	修复了自动登录功能
	TASK:1.dbus 2.老师布置的任务
	22:47 现在完成了dbus的编译环境，api还没有找到。。。
	23:35 完成文本文档由unix到dos格式的批量转换，便于老师在Windows下阅读。
2009年04月20日 星期一 14时47分08秒
	今天下午见李老师，向老师详细报告了sendpacket的内容，并把整个工程的结构向老师描述了一遍。
	布置如下任务：
	RADIUS和EAPOL的联系,RADIUS用什么协议？
	认证服务器的MAC地址交换机如何得到？
	服务器对激活包的返回包是什么？
	Alog和MD5的了解
	三次握手
2009年04月20日 星期一 00时57分08秒
	研读了sendpacket文件，搞定！下一步是blog和md5文件的研究。还有dbus的实现...
2009年04月10日 星期五 08时08分25秒
	dropbox的Public不能下载了，这下没地方发布了，想来想去只有google code了。于是在google code上创建项目，重新用上了svn.
2009年04月09日 星期四 14时16分28秒
	用recordmydesktop录制了使用效果演示，默认是ogv格式的，又用mencoder转为avi格式的。
	提交更新错误，难道因为好久没提交了，删错文件了？索性将版本控制由svn改为git了，虽然对svn还没有完全了解，而且对git更不了解。。。
2009年04月09日 星期四 13时35分41秒
	完成tray图标的修改，初始时有一红杠，表示不连通，当认证成功后，红杠消失，可以上网。
2009年04月09日 星期四 13时08分53秒
	好几天没写了，一来在忙复试，二来在研究gmChat。现在gMstar已经差不多了，作了tray图标，感觉不好看，又更新了一个，很像NetWorkManager的。传到了dropbox上，在校内贴了url，期待大家的测试！
	看上次的任务，第3条完成了
2009年04月03日 星期五 01时07分39秒
	今天收获很大！特别感谢lerosua前辈的热心指导！是lerosua让我学会了使用线程，还有参考了lerosua的大作gmlive，学会了statusicon的使用！现在锐捷可以最小化到托盘了，并且我经过查资料和实践，发现gtkmm要用glade的话，最好不要继承自Window，除非你只想使用glade文件的一部分，并且要自己再建一遍ui。网上有继承自Main的，而我在gMystar里使用的不继承。用一个Window指针做成员，可以直接指向初始化的glade界面！其实本来gMystar一直是继承自Mystar的，但由于信号的连接要静态成员函数，而Mystar的authen一静态几乎全部都静态了，所以我决定让Mystar做gMystar的成员。
	现在可以发布使用了，剩下的是优化了！
	下面的任务：1。信号的断开2.程序的退出3。打包发布4.交叉编译到windows5.基础学习
2009年04月01日 星期三 15时18分49秒
	今天下载了chat聊天软件，作为新工程的开始。而gmystar还没有一点进展：一直在研究进程，线程！
	下一步要学习的任务：1.c++学习，包括const，static等的理解 2.进程学习 3.线程学习 4.信号处理
2009年03月31日 星期二 21时57分00秒
	vim重新用上了时间戳，以后ChangeLog不用自己输时间了！
2009-03-31 21:09
	今晚研究tray。把main从gmystar.cc中分离出来了，提高gmystar的可重用性.
2009-03-31 17:30
	成功实现xml配置文件的解析！又修改Makefile文件，实现后缀法批量编译，学习了静态连接和动态连接，makefile函数。
	下面的任务：1。glade设计2.信号处理
2009-03-30 23:51
	今天会用string类了，get_text搞定。晚上研究xml到现在仍没成功。解析器太多，不知如何选择。有xerces-c,libxml,libxml2,libxml++,expat,xqilla,libpath,tinyxml,tinyxml++等。。。决定用tinyxml
	那么得研究gcc和g++的参数问题了，具体是编译过程额研究，什么动态库，静态库，include，lib，预处理，汇编，链接等。明天把这一块搞明白，希望可以解析xml.
2009-03-27 00:17
	今晚（其实是26号晚）准备研究那个大循环，想拆成分别发包，但好像现在时机还不成熟，我对包的机制还不太了解。。。
	UI中除了读取配置文件显示外，还要读取最终用户输入或修改的数据，set_text的参数可以是char*，但get_text()的返回值是GLib::ustring，是utf8 string，不知道如何转换成char*？
2009-03-25 11:32
	今天上午完成了svn+apache2的配置.现在开始用svn进行版本控制了，只是还不会用分支。。。
	那么下面要做的是：1.信号处理;2.glade设计;3.打包处理
2009-03-25 01:22
	才发现每次写都过了十二点。。。
	今晚（准确说是昨晚）小研究了一下编码转换，这次终于成功了！
	学习了中文gb2312的编码，utf8编码太复杂了，留待以后进一步的学习，现在发布是没问题了。
	今天安装了git，那么现在cvs，git，svn全有了，还有一个教barra什么的，改天小觑一下。。
	打包看了下，得从autotool做起，太复杂，最后做吧。
	信号处理得好好研究一下，还有glade和gtkmm的学习！
	那么下面要做的是：1.信号处理;2.glade设计;3.cvs搭建4.打包处理
2009-03-24
	昨晚开始研究sendpackage.cc文件，原来没有设置ip，所以老出现ip绑定错误;没有读取配置文件种的echointerval，所以是假的keep sending echo。
	编码问题，暂时不会解决，不过我现在把十六进制码输出出来了，有空可以细细研究一下。
	现在已可以用gMystar上网了，只是信号处理部分还没整明白，ctrl+c还不能logout，而是中断程序，网还联着。。。但不send echo了，那我想也持续不了多久吧？
	还有GUI，网能连上后就假死，真无语。
	修改了配置文件，增加了install，复制gMystar,gMystar.glade,gMystar.conf到~/bin
	下面要做的是：1.编码转换;2.信号处理;3.glade设计;4.打包处理5.cvs搭建
2009-03-14
	做了一晚上的编码转换，还是还有搞定!iconv的C函数介绍太少了，iconv太难用了。。。现在能把gbk转换成乱七八糟的东西，也能转换成空，就是不能正确转换！
	研究了一下EAP，将原来的search_server方法更名为eapol，这样更符合逻辑，因为其中包含了整个报文的收发，而不仅仅是寻找服务器。这个函数和那张图现在高度对应了！
	下一步继续编码转换，还有就是研究sendpackage.cc文件了！
	今晚初次安装Debian，现在还在配置apt，之前的界面都很不错，安装也很快，就这里慢！难道是联网的缘故？
	对了，还有问题，发的包可能不对，因为老显示IP绑定错误，而其实应是达到用户数量上限，即别人已用了。这在研究sendpackage时能找到答案吧！
	现在是00:49,还在配置apt，索性把网线拔了，应该会快点吧，装完就睡！
2009-03-08
	用gdb和插入printf信息来调试search_server函数，简化为一次验证，并且运行成功
	iconv改来自服务器的gbk编码信息未果，iconv_open和iconv_close都会用了，但iconv函数的size_t *参数不好填，用int *代替还不行！明天继续查！
	界面还有改：GUI中默认回车就可联，但初始光标还应在最上面的输入框里，而focus到连接按钮上；命令行下通过参数控制GUI的显示，类似mplayer那样，用--nogui参数不显示GUI,但这样的话命令行就要自动连接了！GuI里面也可以设自动连接的其实！
	说干就干！现在23:58...
	现在00:37！现在有GUI和CLI两种模式，Makefile里也有了run和runc来运行gui和cli，原来c++的类实例化时，若无参则连括号都不要！
	在CLI模式下添加help没有成功，关于静态函数的用法明天查书吧！睡觉！已00:47了！
2009-02-08
	找到KStar，C++和qt改进的mystar。
	用dia画了search_server的流程图，
2009-01-24
	TODO:notification area show
2009-01-23
	TODO:xmldom解析mystar.xml,用xerces-c库和xqilla库
2009-01-21
	对象化大致完成。可运行。
	有User类，MD5类，Mystar类，gMystar类。
	Makefile文件也实现了分目录
2009-01-20
	学会了makefile多文件部署。之前已将mystar.cc构造成功。
	模块化myerr.o, sendpaket.o,User.o, MD5.o, Mystar.o,gMystar.o
	初步学会用glade进行界面设计，能够连接gtkmm和libglade进行事件关联。
	撤销了静态链接
2008-11-25
	改mystar.c 为mystar.cc，重构了代码，建了mystar类。但不能运行。
2008-11-23
	cvs配置完成，这是第一份在cvs下的添加，成功。
2008-11-14
	格式化工作：用indent格式化为gnu风格，又把那些十六进制数排的更好看些。
	修改为自动退出，当认证成功或失败时。因为服务器用的gb2312编码，而我用utf8，所以显示的信息是乱码，为了能转换编码，只好退出从而在脚本中用iconv转换。
	启用fakeAddress，虽然现在还不知道如何使用。
	修改目录，使更美观。用bin存可执行程序，obj下放中间文件，本来要把.c和.h放入src或lib中，但makefile貌似最好放在首目录下，所以就没有这样做了。这样也好，直接编辑，直接编译，直接运行。
	当然要修改makefile文件了。再加一个run选项！但没成功。
